{"files": [{"path": "README.md", "content": "# Mini AI Project\n\nThis is a simple character-level Markov chain generator implemented in Python without using any external libraries like numpy, pandas, sklearn, torch, tensorflow, or requests.\n\n## Features\n\n- Character-level Markov chain generator\n- Training from text files\n- Command Line Interface (CLI) for training and generating text\n\n## Installation\n\n1. Clone the repository: `git clone https://github.com/yourusername/mini_ai.git`\n2. Navigate to the project directory: `cd mini_ai`\n3. Install dependencies: `pip install -r requirements.txt` (if any)\n\n## Usage\n\n### Training\n```sh\npython -m mini_ai.cli train --input your_text_file.txt\n```\n\n### Generating Text\n```sh\npython -m mini_ai.cli generate --model model.pkl --length 100\n```\n\n## Tests\nTo run the tests, use:\n```sh\npython -m unittest discover\n```\n"
}, {"path": "mini_ai/__init__.py", "content": "from .markov import MarkovChain, train, generate\n" }, {"path": "mini_ai/markov.py", "content": "import random\n\nclass MarkovChain:\n    def __init__(self):\n        self.chain = {}\n\n    def add_sentence(self, sentence):\n        for i in range(len(sentence) - 1):\n            if sentence[i] not in self.chain:\n                self.chain[sentence[i]] = []\n            self.chain[sentence[i]].append(sentence[i + 1])\n\n    def generate_text(self, length):\n        start = random.choice(list(self.chain.keys()))\n        text = [start]\n        while len(text) < length:\n            if text[-1] in self.chain:\n                next_char = random.choice(self.chain[text[-1]])\n                text.append(next_char)\n            else:\n                break\n        return ''.join(text)\n\ndef train(file_path):\n    with open(file_path, 'r', encoding='utf-8') as file:\n        text = file.read()\n    markov = MarkovChain()\n    markov.add_sentence(text)\n    return markov\n\ndef generate(model, length):\n    return model.generate_text(length)\n" }, {"path": "mini_ai/cli.py", "content": "import argparse\nfrom .markov import train, generate\n\ndef main():\n    parser = argparse.ArgumentParser(description='Train or generate text using a Markov chain.')\n    subparsers = parser.add_subparsers(dest='command')\n\n    # Subparser for training\n    train_parser = subparsers.add_parser('train', help='Train the model on a given text file.')\n    train_parser.add_argument('--input', type=str, required=True, help='Path to the input text file.')\n\n    # Subparser for generating text\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained model.')\n    generate_parser.add_argument('--model', type=str, required=True, help='Path to the saved model file.')\n    generate_parser.add_argument('--length', type=int, required=True, help='Length of the generated text.')\n\n    args = parser.parse_args()\n\n    if args.command == 'train':\n        markov_model = train(args.input)\n        # Save the model here if needed\n        print('Model trained successfully.')\n    elif args.command == 'generate':\n        with open(args.model, 'rb') as file:\n            model = pickle.load(file)\n        generated_text = generate(model, args.length)\n        print(generated_text)\n\nif __name__ == '__main__':\n    main()\n" }, {"path": "tests/test_markov.py", "content": "import unittest\nfrom mini_ai.markov import MarkovChain, train, generate\n\nclass TestMarkov(unittest.TestCase):\n    def test_add_sentence(self):\n        markov = MarkovChain()\n        markov.add_sentence('hello world')\n        self.assertEqual(markov.chain, {'h': ['e'], 'e': ['l'], 'l': ['o', 'o'], 'o': [' '], ' ': ['w'], 'w': ['o'], 'r': ['d']})\n\n    def test_generate_text(self):\n        markov = MarkovChain()\n        markov.chain = {'h': ['e'], 'e': ['l'], 'l': ['o', 'o'], 'o': [' '], ' ': ['w'], 'w': ['o'], 'r': ['d']}\n        text = markov.generate_text(10)\n        self.assertEqual(len(text), 10)\n\n    def test_train(self):\n        model = train('tests/test_input.txt')\n        self.assertIsNotNone(model)\n\n    def test_generate(self):\n        markov = MarkovChain()\n        markov.chain = {'h': ['e'], 'e': ['l'], 'l': ['o', 'o'], 'o': [' '], ' ': ['w'], 'w': ['o'], 'r': ['d']}\n        generated_text = generate(markov, 10)\n        self.assertEqual(len(generated_text), 10)\n\nif __name__ == '__main__':\n    unittest.main()\n" }, {"path": "tests/test_cli.py", "content": "import unittest\nfrom unittest.mock import patch\nimport mini_ai.cli as cli\n\nclass TestCLI(unittest.TestCase):\n    @patch('sys.stdout', new_callable=io.StringIO)\n    def test_train(self, mock_stdout):\n        cli.main(['mini_ai.cli', 'train', '--input', 'tests/test_input.txt'])\n        self.assertIn('Model trained successfully.', mock_stdout.getvalue())\n\n    @patch('sys.stdout', new_callable=io.StringIO)\n    def test_generate(self, mock_stdout):\n        cli.main(['mini_ai.cli', 'generate', '--model', 'tests/test_model.pkl', '--length', 100])\n        self.assertIn('Generated text length should be exactly as specified.', mock_stdout.getvalue())\n\nif __name__ == '__main__':\n    unittest.main()\n" }, {"path": "tests/test_input.txt", "content": "hello world this is a test input for the markov chain model training."}], "notes": "optional"}