{"mode": "full", "files": [{"path": "README.md", "content": "# Mini AI Project\n\nThis is a simple implementation of a character-level Markov chain generator using Python.\n\n## Features\n\n- Implements a MarkovChain class with methods to train and generate text based on the trained model.\n- Provides a CLI for training the model from a text file and generating new text based on the trained model.\n\n## Installation\n\nTo install this package, you can use pip:\n```bash\npip install .\n```\n\n## Usage\n\n### Training the Model\n\nYou can train the model using a text file with the following command:\n```bash\npython -m mini_ai.cli train --input <path-to-text-file> --model-out <path-to-output-json> --order <int>\n```\n\n### Generating Text\n\nYou can generate text using the trained model with the following command:\n```bash\npython -m mini_ai.cli generate --model <path-to-model-json> --length <int> [--seed <str>] [--random-seed <int>]\n```\n\n## Documentation\n\nFor more details, please refer to the documentation included in the repository.\n"}, {"path": "mini_ai/__init__.py", "content": "from .markov import MarkovChain\n__all__ = ['MarkovChain']\n"}, {"path": "mini_ai/markov.py", "content": "import random\nfrom collections import defaultdict\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        if order <= 0:\n            raise ValueError(\"Order must be a positive integer.\")\n        self.order = order\n        self.transitions = defaultdict(lambda: defaultdict(int))\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            self.transitions[context][next_char] += 1\n\n    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\n        if random_seed is not None:\n            random.seed(random_seed)\n        if seed is None:\n            context = \"\"\n        else:\n            context = seed[:self.order]\n\n        result = list(context)\n        for _ in range(length - self.order):\n            if context not in self.transitions:\n                break\n            choices_dict = dict(self.transitions[context])\n            next_char = random.choices([k for k in choices_dict], weights=choices_dict.values())[0]\n            result.append(next_char)\n            context = context[1:] + next_char\n\n        return \"\".join(result)\n\n    def to_dict(self) -> dict:\n        return {\n            \"order\": self.order,\n            \"transitions\": {k: dict(v) for k, v in self.transitions.items()}\n        }\n\n    @classmethod\n    def from_dict(cls, d: dict) -> \"MarkovChain\":\n        mc = cls(order=d[\"order\"])\n        mc.transitions = defaultdict(lambda: defaultdict(int), d[\"transitions\"不得不说，这确实是一个挑战，但也是一个学习和提高编程技能的好机会。希望这个实现能够满足你的需求，并且能够在实践中应用和改进。如果还有其他问题或需要进一步的帮助，请随时告诉我！\"])\n        return mc\n"}, {"path": "mini_ai/cli.py", "content": "import argparse\nimport json\nfrom .markov import MarkovChain\n\ndef main(argv: list[str] | None = None) -> int:\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers()\n\n    train_parser = subparsers.add_parser(\"train\")\n    train_parser.add_argument(\"--input\", type=str, required=True)\n    train_parser.add_argument(\"--model-out\", type=str, required=True)\n    train_parser.add_argument(\"--order\", type=int, required=True)\n    train_parser.set_defaults(func=train)\n\n    generate_parser = subparsers.add_parser(\"generate\")\n    generate_parser.add_argument(\"--model\", type=str, required=True)\n    generate_parser.add_argument(\"--length\", type=int, required=True)\n    generate_parser.add_argument(\"--seed\", type=str, default=None)\n    generate_parser.add_argument(\"--random-seed\", type=int, default=None)\n    generate_parser.set_defaults(func=generate)\n\n    args = parser.parse_args(argv)\n    return args.func(args)\n\ndef train(args) -> int:\n    with open(args.input, \"r\", encoding=\"utf-8\") as f:\n        text = f.read()\n    mc = MarkovChain(order=args.order)\n    mc.train(text)\n    with open(args.model_out, \"w\", encoding=\"utf-8\") as f:\n        json.dump(mc.to_dict(), f)\n    return 0\n\ndef generate(args) -> int:\n    with open(args.model, \"r\", encoding=\"utf-8\") as f:\n        model_data = json.load(f)\n    mc = MarkovChain.from_dict(model_data)\n    generated_text = mc.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\n    print(generated_text)\n    return 0\n"}],"notes": "optional"}