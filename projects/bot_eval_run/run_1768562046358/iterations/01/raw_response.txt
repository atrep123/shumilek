{"mode": "full", "files": [{"path": "README.md", "content": "# Mini AI Project\n\nThis is a simple character-level Markov chain generator implemented in Python without using any external libraries.\n\n## Installation\n\nYou can install the package by running:\n\n```bash\npip install .\n```\n\n## Usage\n\n### Training Model\n\nTo train a Markov model, use the following command:\n\n```bash\npython -m mini_ai.cli train --input <path> --model-out <path> --order <int>\n```\n\nExample:\n\n```bash\npython -m mini_ai.cli train --input data.txt --model-out model.json --order 1\n```\n\n### Generating Text\n\nTo generate text using the trained model, use the following command:\n\n```bash\npython -m mini_ai.cli generate --model <path> --length <int> [--seed <str>] [--random-seed <int>]\n```\n\nExample:\n\n```bash\npython -m mini_ai.cli generate --model model.json --length 100 --seed 'a' --random-seed 42\n```\n\n## Documentation\n\nFor detailed documentation, please refer to the [API documentation](#).\n\n## License\n\nThis project is licensed under the MIT License.\n\n"}, {"path": "mini_ai/__init__.py", "content": "# mini_ai package\n\n__version__ = \"0.1.0\"\n"}, {"path": "mini_ai/markov.py", "content": "from typing import Dict, Any, Union\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {next_char: 1}\n            else:\n                self.transitions[context][next_char] = self.transitions[context].get(next_char, 0) + 1\n\n    def generate(self, length: int, seed: str = None, random_seed: int = None) -> str:\n        import random\n        if random_seed is not None:\n            random.seed(random_seed)\n        result = []\n        context = seed or \"\"\n        for _ in range(length):\n            if context in self.transitions:\n                next_char = random.choices(\n                    list(self.transitions[context].keys()), \n                    list(self.transitions[context].values())\n                )[0]\n                result.append(next_char)\n                context = \"\".join([context[1:], next_char])\n            else:\n                break\n        return \"\".join(result)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\"order\": self.order, \"transitions\": self.transitions}\n\n    @classmethod\n    def from_dict(cls, d: Dict[str, Any]) -> \"MarkovChain\":\n        mc = cls(order=d[\"order\"])  # type: ignore\n        mc.transitions = d[\"transitions\"]\n        return mc\n"}, {"path": "mini_ai/cli.py", "content": "import argparse\nimport json\nfrom mini_ai.markov import MarkovChain\n\ndef main(argv: list[str] | None = None) -> int:\n    parser = argparse.ArgumentParser(description=\"Mini AI CLI\")\n    subparsers = parser.add_subparsers()\n\n    train_parser = subparsers.add_parser(\"train\", help=\"Train the Markov model\")\n    train_parser.add_argument(\"--input\", required=True, type=str, help=\"Input text file path\")\n    train_parser.add_argument(\"--model-out\", required=True, type=str, help=\"Output model file path\")\n    train_parser.add_argument(\"--order\", required=True, type=int, help=\"Order of the Markov chain\")\n    train_parser.set_defaults(func=train)\n\n    generate_parser = subparsers.add_parser(\"generate\", help=\"Generate text using the model\")\n    generate_parser.add_argument(\"--model\", required=True, type=str, help=\"Model file path\")\n    generate_parser.add_argument(\"--length\", required=True, type=int, help=\"Length of the generated text\")\n    generate_parser.add_argument(\"--seed\", type=str, help=\"Seed for text generation\")\n    generate_parser.add_argument(\"--random-seed\", type=int, help=\"Random seed for reproducibility\")\n    generate_parser.set_defaults(func=generate)\n\n    args = parser.parse_args(argv)\n    return args.func(args)\n\ndef train(args):\n    with open(args.input, \"r\", encoding=\"utf-8\") as file:\n        text = file.read()\n    model = MarkovChain(order=args.order)\n    model.train(text)\n    with open(args.model_out, \"w\", encoding=\"utf-8\") as file:\n        json.dump(model.to_dict(), file)\n    return 0\n\ndef generate(args):\n    with open(args.model, \"r\", encoding=\"utf-8\") as file:\n        model_data = json.load(file)\n    model = MarkovChain.from_dict(model_data)\n    generated_text = model.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\n    print(generated_text)\n    return 0\n"}], "notes": "optional"}