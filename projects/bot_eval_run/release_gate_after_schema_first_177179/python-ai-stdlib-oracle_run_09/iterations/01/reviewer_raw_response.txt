{
  "mode": "full",
  "files": [
    {"path": "README.md", "content": "\n# Mini AI\nA simple character-level Markov chain generator for generating text.\n"},
    {"path": "mini_ai/__init__.py", "content": ""},
    {"path": "mini_ai/markov.py", "content": "from typing import Dict, List, Optional, Tuple, Union\nimport json\nimport os\nimport random\nimport string\nfrom collections import defaultdict\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))\n\n    @classmethod\n    def from_dict(cls, d: dict) -> 'MarkovChain':\n        return cls(order=d['order'], transitions=d['transitions'])\n\n    def to_dict(self) -> dict:\n        return {\n            'order': self.order,\n            'transitions': self.transitions\n        }\n\n    def train(self, text: str):\n        if not text or len(text) < self.order + 1:\n            raise ValueError('Text must be at least order+1 characters long.')\n\n        for i in range(len(text) - self.order):\n            context = text[i:i+self.order]\n            next_char = text[i+self.order]\n            if context not in self.transitions or next_char not in self.transitions[context]:\n                continue\n            self.transitions[context][next_char] += 1\n\n    def generate(self, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        if length <= 0 or length > len(text):\n            raise ValueError('Length must be positive and less than the text length.')\n\n        if not self.transitions:\n            raise ValueError('Model has not been trained yet. Please call train() first.')\n\n        random.seed(random_seed)\n        seed = seed or ''.join(random.choices(string.ascii_letters, k=self.order))\n        context = seed\n        result = []\n\n        for _ in range(length):\n            if context not in self.transitions:\n                break\n            next_char_count = sum(self.transitions[context].values())\n            probabilities = {char: count / next_char_count for char, count in self.transitions[context].items()}\n            next_char = random.choices(list(probabilities.keys()), list(probabilities.values()))[0]\n            result.append(next_char)\n            context = context[1:] + next_char\n        return ''.join(result)"},
    {"path": "mini_ai/cli.py", "content": "import argparse\nfrom typing import List, Optional, Tuple\nfrom mini_ai.markov import MarkovChain\n\ndef main(argv: List[str] | None = None) -> int:\n    parser = argparse.ArgumentParser(description='Mini AI CLI for generating text using a Markov chain model.')\n    subparsers = parser.add_subparsers(dest='command', help='sub-command help')\n\n    train_parser = subparsers.add_parser('train', help='Train the Markov chain model from input text and save to output file.')\n    train_parser.add_argument('--input', required=True, type=str, help='Path to input text file.')\n    train_parser.add_argument('--model-out', required=True, type=str, help='Path to save trained model as JSON file.')\n    train_parser.add_argument('--order', type=int, default=1, help='Order of the Markov chain (default: 1).')\n\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained Markov chain model.')\n    generate_parser.add_argument('--model', required=True, type=str, help='Path to loaded JSON model file.')\n    generate_parser.add_argument('--length', type=int, default=10, help='Length of generated text (default: 10).')\n    generate_parser.add_argument('--seed', type=str, help='Seed for deterministic generation. If not provided, a random seed will be used.')\n    generate_parser.add_argument('--random-seed', type=int, help='Random seed for deterministic generation. If not provided, a new seed will be generated.')\n\n    args = parser.parse_args(argv)\n    if args.command == 'train':\n        return train(args.input, args.model_out, args.order)\n    elif args.command == 'generate':\n        return generate(args.model, args.length, args.seed, args.random_seed)\n    else:\n        parser.print_help()\n        return 1\n\nMARKOV_CHAIN = MarkovChain()\n\ndef train(input_path: str, model_out: str, order: int) -> None:\n    with open(input_path, 'r', encoding='utf-8') as f:\n        text = f.read()\n    MARKOV_CHAIN.train(text)\n    with open(model_out, 'w', encoding='utf-8') as f:\n        json.dump(MARKOV_CHAIN.to_dict(), f, ensure_ascii=False)\n\nMARKOV_CHAIN = MarkovChain()\n\ndef generate(model_path: str, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> None:\n    with open(model_path, 'r', encoding='utf-8') as f:\n        model_dict = json.load(f)\n    model = MarkovChain.from_dict(model_dict)\n    result = model.generate(length, seed, random_seed)\n    print(result)"}
  ]
}