{
  "mode": "full",
  "files": [
    {"path": "README.md", "content": "\n# Mini AI\nA simple Markov chain generator for text generation.\n"},
    {"path": "mini_ai/__init__.py", "content": "}\n"},
    {"path": "mini_ai/markov.py", "content": "from typing import Dict, List, Optional, Tuple\nimport json\nimport random\nimport string\n\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n        self.counts: Dict[str, int] = {}\n\n    @classmethod\n    def from_dict(cls, d: dict) -> 'MarkovChain':\n        return cls(order=d['order'], transitions=d['transitions'])\n\n    def to_dict(self) -> dict:\n        return {\n            'order': self.order,\n            'transitions': self.transitions,\n        }\n\n    def train(self, text: str):\n        if not text or len(text) < self.order:\n            raise ValueError('Text is too short for the specified order.')\n\n        context = [text[i] for i in range(max(0, self.order - 1), len(text))]\n        next_chars = [text[i + self.order] for i in range(len(text) - self.order)]\n\n        for i in range(len(context) - self.order):\n            key = tuple(context[i:i+self.order])\n            if key not in self.transitions:\n                self.transitions[key] = {}\n            next_char = next_chars[i]\n            if next_char not in self.transitions[key]:\n                self.counts[key] = 0\n            self.transitions[key][next_char] = self.transitions[key].get(next_char, 0) + 1\n            self.counts[key] += 1\n\n    def generate(self, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        if not length or length <= 0:\n            raise ValueError('Length must be a positive integer greater than zero.')\n\n        if seed is not None and random_seed is not None:\n            raise ValueError('Both seed and random_seed cannot be provided at the same time.')\n\n        context = tuple([random.choice(string.ascii_letters) for _ in range(self.order)])\n        result = []\n        for _ in range(length):\n            if context not in self.transitions:\n                break\n            next_char, count = max(self.transitions[context].items(), key=lambda x: random.random() * x[1] / self.counts[context])\n            result.append(next_char)\n            context = tuple(context[1:] + (next_char,))\n        return ''.join(result)"}
    ],
    "notes": "The MarkovChain class now handles the training and generation logic as per the requirements. The README.md file provides a brief description of the project."
}