{
  "mode": "full",
  "files": [
    {
      "path": "README.md",
      "content": "\n# Mini AI\nA simple character-level Markov chain generator for generating text.\n"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": ""
    },
    {
      "path": "mini_ai/markov.py",
      "content": "from typing import Dict, List, Optional, Tuple, Union\nimport json\nimport random\nimport string\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n        self.counts: Dict[str, int] = {}\n\n    @classmethod\n    def from_dict(cls, d: dict) -> 'MarkovChain':\n        mc = cls(d['order'])\n        mc.transitions = d['transitions']\n        return mc\n\n    def to_dict(self) -> dict:\n        return {\n            'order': self.order,\n            'transitions': self.transitions\n        }\n\n    def train(self, text: str):\n        if not text or len(text) < self.order:\n            raise ValueError('Text must be at least as long as the order.')\n\n        for i in range(len(text) - self.order + 1):\n            context = text[i:i+self.order]\n            next_char = text[i+self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {}\n            if next_char not in self.transitions[context]:\n                self.counts[context] = 0\n            self.transitions[context][next_char] = self.transitions[context].get(next_char, 0) + 1\n            self.counts[context] += 1\n\n    def generate(self, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        if not length or length <= 0:\n            raise ValueError('Length must be a positive integer greater than zero.')\n\n        context = self._get_initial_context(seed)\n        result = [random.choice(list(self.transitions[context].keys()))]\\n        for _ in range(length - 1):\n            next_char = random.choices(list(self.transitions[context].keys()), weights=[self.counts[context][c] for c in list(self.transitions[context].keys())], k=1)[0]\n            result.append(next_char)\n            context = self._get_next_context(context, next_char)\n\n        return ''.join(result)\n\n    def _get_initial_context(self, seed: Optional[str]) -> str:\n        if not seed or len(seed) < self.order:\n            seed = ''.join(random.choices(string.ascii_letters + string.digits, k=self.order))\n        return seed[:self.order]\n\n    def _get_next_context(self, context: str, next_char: str) -> str:\n        if context == '' or len(context) < self.order - 1:\n            raise ValueError('Context must be at least as long as the order minus one.')\n        return context[1:] + next_char\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nfrom mini_ai.markov import MarkovChain\n\ndef main(argv: list[str] | None = None) -> int:\n    parser = argparse.ArgumentParser(description='Mini AI CLI for generating text using a Markov chain model.')\n    subparsers = parser.add_subparsers(dest='command', help='Subcommands')\n\n    train_parser = subparsers.add_parser('train', help='Train the Markov chain model and save it to a JSON file.')\n    train_parser.add_argument('--input', type=str, required=True, help='Input text file path.')\n    train_parser.add_argument('--model-out', type=str, required=True, help='Output model file path.')\n    train_parser.add_argument('--order', type=int, default=1, help='Order of the Markov chain (default: 1).')\n\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained Markov chain model.')\n    generate_parser.add_argument('--model', type=str, required=True, help='Model file path to load.')\n    generate_parser.add_argument('--length', type=int, default=10, help='Length of the generated text (default: 10).')\n    generate_parser.add_argument('--seed', type=str, help='Seed for deterministic generation.')\n    generate_parser.add_argument('--random-seed', type=int, help='Random seed for deterministic generation.')\n\n    args = parser.parse_args(argv)\n\n    if args.command == 'train':\n        return train(args.input, args.model_out, args.order)\n    elif args.command == 'generate':\n        return generate(args.model, args.length, args.seed, args.random_seed)\n\n    return 1\n\nMARKOV_CHAIN = MarkovChain()\n\ndef train(input_path: str, model_out: str, order: int) -> None:\n    with open(input_path, 'r', encoding='utf-8') as f:\n        text = f.read()\n    MARKOV_CHAIN.train(text)\n    with open(model_out, 'w', encoding='utf-8') as f:\n        json.dump(MARKOV_CHAIN.to_dict(), f, ensure_ascii=False, indent=4)\n\nMARKOV_CHAIN = MarkovChain()\n\ndef generate(model_path: str, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> None:\n    with open(model_path, 'r', encoding='utf-8') as f:\n        model_dict = json.load(f)\n    MARKOV_CHAIN.from_dict(model_dict)\n    result = MARKOV_CHAIN.generate(length, seed, random_seed)\n    print(result)"
    }
  ]
}