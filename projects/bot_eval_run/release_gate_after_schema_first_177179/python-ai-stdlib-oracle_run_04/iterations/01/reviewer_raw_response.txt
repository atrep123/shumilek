{
  "mode": "full",
  "files": [
    {"path": "README.md", "content": "\n# Mini AI\nA simple character-level Markov chain generator for generating text.\n"},
    {"path": "mini_ai/__init__.py", "content": ""},
    {"path": "mini_ai/markov.py", "content": "from typing import Dict, List, Optional, Tuple, Union\nimport json\nimport random\nimport string\n\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n        self.counts: Dict[str, int] = {}\n\n    @classmethod\n    def from_dict(cls, d: dict) -> 'MarkovChain':\n        mc = cls(d['order'])\n        mc.transitions = d['transitions']\n        return mc\n\n    def to_dict(self) -> dict:\n        return {\n            'order': self.order,\n            'transitions': self.transitions\n        }\n\n    def train(self, text: str):\n        if not text or len(text) < self.order:\n            raise ValueError('Text must be at least as long as the order.')\n        for i in range(len(text) - self.order + 1):\n            context = text[i:i+self.order]\n            next_char = text[i+self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {}\n            if next_char not in self.transitions[context]:\n                self.counts[context] = 0\n            self.transitions[context][next_char] = self.counts[context] + 1\n            self.counts[context] += 1\n        return None\n\n    def generate(self, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        if not length or length <= 0:\n            raise ValueError('Length must be greater than zero.')\n        result = []\n        context = self._get_initial_context(seed)\n        for _ in range(length):\n            next_char, random_seed = self._next_char(context, seed, random_seed)\n            result.append(next_char)\n            if not self.transitions.get(context, {}):\n                break\n            context = context[:-1] + next_char\n        return ''.join(result)\n\n    def _get_initial_context(self, seed: Optional[str]) -> str:\n        if seed is None:\n            seed = random.randint(0, 2**32 - 1)\n        initial_context = self._generate_seed(seed)\n        return initial_context[-self.order :]\n\n    def _next_char(self, context: str, seed: Optional[str], random_seed: Optional[int]) -> Tuple[str, int]:\n        if not context:\n            raise ValueError('Context cannot be empty.')\n        next_char = self._generate_next_char(context, seed)\n        return (next_char, random_seed)\n\n    def _generate_next_char(self, context: str, seed: Optional[str]) -> str:\n        choices = list(self.transitions[context].keys())\n        if not choices:\n            raise ValueError('No more possible characters for the given context.')\n        probabilities = [self.counts[c] / self.counts[context] for c in choices]\n        random.seed(random_seed)\n        index = random.choices(population=choices, weights=probabilities)[0]\n        return index\n\n    def _generate_seed(self, seed: int) -> str:\n        return ''.join(random.choice(string.ascii_letters) for _ in range(16))\n"},
    {"path": "mini_ai/cli.py", "content": "import argparse\nfrom typing import List, Optional\nfrom mini_ai.markov import MarkovChain\n\n\ndef main(argv: Optional[List[str]] = None):\n    parser = argparse.ArgumentParser(description='Mini AI CLI')\n    subparsers = parser.add_subparsers(dest='command', help='sub-command help')\n\n    train_parser = subparsers.add_parser('train', help='Train the Markov chain model from a text file and save it to a JSON file.')\n    train_parser.add_argument('--input', required=True, type=str, help='Input text file path.')\n    train_parser.add_argument('--model-out', required=True, type=str, help='Output model file path (JSON).')\n    train_parser.add_argument('--order', type=int, default=1, help='Order of the Markov chain. Default is 1.')\n\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained Markov chain model.')\n    generate_parser.add_argument('--model', required=True, type=str, help='Model file path (JSON).')\n    generate_parser.add_argument('--length', type=int, default=10, help='Length of the generated text. Default is 10.')\n    generate_parser.add_argument('--seed', type=str, help='Seed for deterministic generation. Use this with --random-seed to ensure reproducibility.')\n    generate_parser.add_argument('--random-seed', type=int, default=None, help='Random seed for the Markov chain generator. Use this with --seed to ensure reproducibility.')\n\n    args = parser.parse_args(argv)\n\n    if args.command == 'train':\n        markov_chain = MarkovChain(args.order)\n        markov_chain.train(open(args.input, 'r').read())\n        json.dump(markov_chain.to_dict(), open(args.model_out, 'w'))\n        return 0\n\n    elif args.command == 'generate':\n        with open(args.model, 'r') as model_file:\n            markov_chain = MarkovChain.from_dict(json.load(model_file))\n        result = markov_chain.generate(args.length)\n        if args.seed is not None and args.random_seed is not None:\n            random.seed(args.random_seed)\n        return result\n    else:\n        parser.print_help()\n        return 1"}
  ]
}