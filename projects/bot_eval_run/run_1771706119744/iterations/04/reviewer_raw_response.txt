{
  "mode": "full",
  "files": [
    {"path": "README.md", "content": "...\nThis is a simple Markov Chain generator for AI projects.\n"},
    {"path": "mini_ai/__init__.py", "content": "from .markov import MarkovChain\n"},
    {"path": "mini_ai/markov.py", "content": "import json\nimport os\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i+self.order]\n            next_char = text[i+self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {}\n            if next_char not in self.transitions[context]:\n                self.transitions[context][next_char] = 0\n            self.transitions[context][next_char] += 1\n\n    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\n        if not seed and not random_seed:\n            return ''.join([self._generate_one(length - 1) for _ in range(length)])\n        elif seed:\n            context = seed\n            generated_text = []\n            for _ in range(length):\n                next_char, random_seed = self._next_char(context, random_seed)\n                generated_text.append(next_char)\n                context = context[1:] + next_char\n            return ''.join(generated_text)\n        else:\n            raise ValueError('Either seed or random_seed must be provided for deterministic generation.')\n\n    def _generate_one(self, length: int) -> str:\n        if not self.transitions:\n            return ''\n        context = list(self.transitions.keys())[0]\n        generated_text = []\n        for _ in range(length):\n            next_char, random_seed = self._next_char(context, random_seed)\n            generated_text.append(next_char)\n            context = context[1:] + next_char\n        return ''.join(generated_text)\n\n    def _next_char(self, context: str, random_seed: int | None) -> tuple[str, int]:\n        import random\n        if not self.transitions.get(context):\n            raise ValueError(f'Context {context} is not in the model.')\n        choices = list(self.transitions[context].keys())\n        probabilities = [self.transitions[context][char] for char in choices]\n        total_prob = sum(probabilities)\n        if random_seed:\n            random.seed(random_seed)\n        choice_index = random.choices(range(len(choices)), weights=probabilities, k=1)[0]\n        next_char = choices[choice_index]\n        return next_char, 0\n\n    def to_dict(self) -> dict:\n        return self.transitions"},
    {"path": "mini_ai/cli.py", "content": "import argparse\nfrom .markov import MarkovChain\n\ndef main(argv: list[str] | None = None) -> int:\n    parser = argparse.ArgumentParser(description='Markov Chain Text Generator')\n    subparsers = parser.add_subparsers(dest='command', required=True)\n\n    # Train command\n    train_parser = subparsers.add_parser('train')\n    train_parser.add_argument('--input', type=str, required=True, help='Path to input text file')\n    train_parser.add_argument('--model-out', type=str, required=True, help='Path to save the trained model')\n    train_parser.add_argument('--order', type=int, required=True, help='Order of the Markov chain')\n\n    # Generate command\n    generate_parser = subparsers.add_parser('generate')\n    generate_parser.add_argument('--model', type=str, required=True, help='Path to trained model JSON file')\n    generate_parser.add_argument('--length', type=int, required=True, help='Length of the generated text')\n    generate_parser.add_argument('--seed', type=str, default=None, help='Seed string for deterministic generation')\n    generate_parser.add_argument('--random-seed', type=int, default=None, help='Random seed for reproducibility')\n\n    args = parser.parse_args(argv)\n\n    if args.command == 'train':\n        with open(args.input, 'r', encoding='utf-8') as f:\n            text = f.read()\n        mc = MarkovChain(order=args.order)\n        mc.train(text)\n        with open(args.model_out, 'w', encoding='utf-8') as f:\n            json.dump(mc.to_dict(), f)\n        return 0\n    elif args.command == 'generate':\n        with open(args.model, 'r', encoding='utf-8') as f:\n            model_data = json.load(f)\n        mc = MarkovChain.from_dict(model_data)\n        generated_text = mc.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\n        print(generated_text)\n        return 0\n    else:\n        parser.print_help()\n        return 1"}
  ],
  "mode": "fix"
}