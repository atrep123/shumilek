{
  "mode": "full",
  "files": [
    {
      "path": "README.md",
      "content": "# mini_ai - Character-level Markov Chain Generator\n\nThis is a simple implementation of a character-level Markov chain generator using the standard Python library.\n\n## Usage\n\n### Training a Model\n\n```bash\npython -m mini_ai.cli train --input <path> --model-out <path> --order <int>\n```\n\n### Generating Text\n\n```bash\npython -m mini_ai.cli generate --model <path> --length <int> [--seed <str>] [--random-seed <int>]\n```\n"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": "# mini_ai package\n\nThis package contains the implementation of a character-level Markov chain generator.\n"
    },
    {
      "path": "mini_ai/markov.py",
      "content": "from __future__ import annotations\nimport json\nimport random\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        if order < 1:\n            raise ValueError(\"Order must be at least 1\")\n        self.order = order\n        self.transitions: dict[str, dict[str, int]] = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {}\n            if next_char not in self.transitions[context]:\n                self.transitions[context][next_char] = 0\n            self.transitions[context][next_char] += 1\n\n    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\n        if random_seed is not None:\n            random.seed(random_seed)\n        if seed and len(seed) >= self.order:\n            context = seed[-self.order:]\n        elif seed and len(seed) < self.order:\n            raise ValueError(f\"Seed must be at least {self.order} characters long\")\n        else:\n            contexts = list(self.transitions.keys())\n            if not contexts:\n                return \"\"\n            context = random.choice(contexts)\n        result = list(seed or context)\n        while len(result) < length:\n            if context in self.transitions:\n                next_char = random.choices(list(self.transitions[context].keys()), weights=list(self.transitions[context].values()))[0]\n                result.append(next_char)\n                context = context[1:] + next_char\n            else:\n                break\n        return ''.join(result)\n\n    def to_dict(self) -> dict:\n        return {\n            \"order\": self.order,\n            \"transitions\": self.transitions\n        }\n\n    @classmethod\ndef from_dict(cls, d: dict) -> \"MarkovChain\":\n        mc = cls(order=d[\"order\"])\n        mc.transitions = d[\"transitions\"]\n        return mc"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nimport json\nfrom mini_ai.markov import MarkovChain\ndef main(argv: list[str] | None = None) -> int:\n    parser = argparse.ArgumentParser(description=\"Character-level Markov Chain Generator\")\n    subparsers = parser.add_subparsers(dest='command')\n\n    # Train command\n    train_parser = subparsers.add_parser('train', help='Train a Markov chain model.')\n    train_parser.add_argument('--input', required=True, help='Path to the input text file.')\n    train_parser.add_argument('--model-out', required=True, help='Path to save the trained model.')\n    train_parser.add_argument('--order', type=int, required=True, help='Order of the Markov chain.')\n\n    # Generate command\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained Markov chain model.')\n    generate_parser.add_argument('--model', required=True, help='Path to the trained model file.')\n    generate_parser.add_argument('--length', type=int, required=True, help='Length of the generated text.')\n    generate_parser.add_argument('--seed', default=None, help='Seed for generation.')\n    generate_parser.add_argument('--random-seed', type=int, default=None, help='Random seed for reproducibility.')\n\n    args = parser.parse_args(argv)\n\n    if args.command == 'train':\n        with open(args.input, encoding='utf-8') as f:\n            text = f.read()\n        mc = MarkovChain(order=args.order)\n        mc.train(text)\n        with open(args.model_out, 'w', encoding='utf-8') as f:\n            json.dump(mc.to_dict(), f)\n        return 0\n    elif args.command == 'generate':\n        with open(args.model, encoding='utf-8') as f:\n            d = json.load(f)\n        mc = MarkovChain.from_dict(d)\n        generated_text = mc.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\n        print(generated_text)\n        return 0\n    else:\n        parser.print_help()\n        return 1"
    }
  ],
  "notes": ""
}