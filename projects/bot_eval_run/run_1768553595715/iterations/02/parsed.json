{
  "files": [
    {
      "path": "README.md",
      "content": "# Mini AI Project\n\nThis is a simple character-level Markov chain generator built as part of a Python project without using any external libraries like numpy, pandas, sklearn, torch, tensorflow, or requests.\n\n## Features\n- Character-level Markov chain model for text generation.\n- Command Line Interface (CLI) for training and generating text.\n\n## Installation\nNo installation required, just run the script with Python.\n\n## Usage\n```sh\npython -m mini_ai.cli train --input yourfile.txt\npython -m mini_ai.cli generate --length 50\n```\n\n## CLI Commands\n- `train`: Train the model on a given text file.\n- `generate`: Generate text based on the trained model.\n\n## Tests\nTo run tests, use:\n```sh\npython -m unittest discover -v -s tests -p \"test*.py\"\n```\n"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": ""
    },
    {
      "path": "mini_ai/markov.py",
      "content": "import random\n\nclass MarkovChain:\n    def __init__(self):\n        self.chain = {}\n\n    def add_text(self, text):\n        words = [\"START\"] + list(text) + [\"END\"]\n        for i in range(len(words) - 1):\n            if words[i] in self.chain:\n                self.chain[words[i]].append(words[i+1])\n            else:\n                self.chain[words[i]] = [words[i+1]]\n\n    def generate_text(self, length):\n        text = \"\"\n        current_word = random.choice(list(self.chain.keys()))\n        while len(text) < length:\n            if current_word != \"END\":\n                text += current_word\n                current_word = random.choice(self.chain[current_word])\n        return text + \"END\"\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nfrom .markov import MarkovChain\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Mini AI CLI for text generation.\")\n    subparsers = parser.add_subparsers(dest='command')\n\n    train_parser = subparsers.add_parser('train', help='Train the model on a given text file.')\n    train_parser.add_argument('--input', required=True, help='Input text file to train on.')\n\n    generate_parser = subparsers.add_parser('generate', help='Generate text based on the trained model.')\n    generate_parser.add_argument('--length', type=int, default=50, help='Length of the generated text.')\n\n    args = parser.parse_args()\n\n    if args.command == 'train':\n        markov = MarkovChain()\n        with open(args.input, 'r') as file:\n            text = file.read().replace('\\n', ' ')\n            markov.add_text(text)\n        print(\"Model trained on input text.\")\n    elif args.command == 'generate':\n        markov = MarkovChain()\n        with open('input.txt', 'r') as file:\n            text = file.read().replace('\\n', ' ')\n            markov.add_text(text)\n        generated_text = markov.generate_text(args.length)\n        print(generated_text)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "path": "tests/test_markov.py",
      "content": "import unittest\nfrom mini_ai.markov import MarkovChain\nimport random\n\nclass TestMarkov(unittest.TestCase):\n    def test_add_text(self):\n        markov = MarkovChain()\n        text = \"hello world\"\n        markov.add_text(text)\n        self.assertEqual(markov.chain, {\"START\": [\"h\"], \"h\": [\"e\"], \"e\": [\"l\"], \"l\": [\"o\", \"a\"], \"o\": [\"w\"], \"w\": [\"o\"], \"o\": [\"r\"], \"r\": [\"d\"], \"d\": [\"END\"]})\n\n    def test_generate_text(self):\n        markov = MarkovChain()\n        text = \"hello world fifteen times\"\n        markov.add_text(text)\n        generated_text = markov.generate_text(10)\n        self.assertIn(\"START\", generated_text)\n        self.assertNotIn(\"fifteen\", generated_text)\n\nif __name__ == '__main__':\n    unittest.main()\n"
    },
    {
      "path": "tests/test_cli.py",
      "content": "import unittest\nfrom unittest.mock import patch\nfrom io import StringIO\nimport sys\nfrom mini_ai.cli import main\n\nclass TestCLI(unittest.TestCase):\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_train(self, mock_stdout):\n        input_text = \"hello world\"\n        sys.argv = ['cli.py', 'train', '--input', input_text]\n        main()\n        self.assertIn('Model trained on input text.', mock_stdout.getvalue())\n\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_generate(self, mock_stdout):\n        with open('input.txt', 'w') as file:\n            file.write(\"hello world\")\n        sys.argv = ['cli.py', 'generate', '--length', '10']\n        main()\n        self.assertIn('START', mock_stdout.getvalue())\n\nif __name__ == '__main__':\n    unittest.main()"
    }
  ],
  "notes": "optional"
}