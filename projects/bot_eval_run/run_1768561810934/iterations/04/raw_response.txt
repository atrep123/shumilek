{
  "mode": "patch",
  "files": [
    {
      "path": "mini_ai/markov.py",
      "content": "from typing import Dict, Optional\nimport random\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        if order <= 0:\n            raise ValueError('Order must be greater than 0')\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i+self.order]\n            next_char = text[i+self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {}\n            if next_char not in self.transitions[context]:\n                self.transitions[context][next_char] = 0\n            self.transitions[context][next_char] += 1\n\n    def generate(self, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        if random_seed is not None:\n            random.seed(random_seed)\n        if seed is not None and len(seed) == self.order:\n            context = seed\n        else:\n            context = random.choice(list(self.transitions.keys()))\n        result = list(context)\n        for _ in range(length - self.order):\n            next_char_options = self.transitions.get(context, {})\n            if not next_char_options:\n                break\n            total_count = sum(next_char_options.values())\n            rand_val = random.randint(1, total_count)\n            cumulative_count = 0\n            for next_char, count in next_char_options.items():\n                cumulative_count += count\n                if rand_val <= cumulative_count:\n                    result.append(next_char)\n                    context = context[1:] + next_char\n                    break\n        return ''.join(result)\n\n    def to_dict(self) -> dict:\n        return {\n            'order': self.order,\n            'transitions': self.transitions\n        }\n\n    @classmethod\ndef from_dict(cls, d: dict) -> MarkovChain:\n        mc = cls(order=d['order'])\n        mc.transitions = d['transitions']\n        return mc"
    }
  ],
  "notes": "Fixed the syntax error in markov.py and completed the generate method."
}