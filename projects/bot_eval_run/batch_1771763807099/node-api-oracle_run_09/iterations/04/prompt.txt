Vytvor realisticky Node.js projekt (bez externich zavislosti), ktery poskytuje REST API pro TODO a projde oracle testy.

POZADAVKY / KONTRAKT:
- Zadne externi npm balicky. Pouze Node.js builtin moduly.
- V kodu NEPOUZIVEJ require/import na nic mimo builtin (napr. zadne "uuid"). Pouzij `node:crypto` (`crypto.randomUUID()`).
- Kód bude v `src/` a bude CommonJS (require/module.exports).
- Soubor `src/server.js` musi exportovat funkci `createServer({ dataPath })`.
- Server musi poskytovat endpointy:
  - GET /health -> 200 JSON { ok: true }
  - GET /openapi.json -> 200 JSON OpenAPI 3.x (musí obsahovat paths pro /todos)
  - GET /todos -> 200 JSON { ok: true, todos: [...] }
  - POST /todos (body {title}) -> 201 JSON { ok: true, todo }
  - GET /todos/:id -> 200 JSON { ok:true, todo } nebo 404 JSON { ok:false, error }
  - PATCH /todos/:id (body {done:true}) -> 200 JSON { ok:true, todo }
  - DELETE /todos/:id -> 200 JSON { ok:true }
- Schema TODO objektu:
  - id: string
  - title: string
  - done: boolean
  - createdAt: ISO string
  - doneAt?: ISO string (jen kdyz done=true)
- Persistuj do souboru `dataPath` jako JSON { "todos": [...] } po kazde mutaci.
- Nevkladej testy do jinych souboru (oracle testy se pridaji zvlast). Nepouzivej duplicity stejnych cest v "files".

Poznamka: testy budeme pouzivat tyto (musis projit):
--- BEGIN ORACLE TESTS (tests/oracle.test.js) ---
const test = require('node:test');
const assert = require('node:assert/strict');
const fs = require('node:fs');
const path = require('node:path');
const os = require('node:os');

function makeTempDir() {
  return fs.mkdtempSync(path.join(os.tmpdir(), 'bot-eval-node-api-'));
}

async function startServer(dataPath) {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const mod = require('../src/server.js');
  assert.equal(typeof mod.createServer, 'function', 'src/server.js must export createServer');
  const server = mod.createServer({ dataPath });
  assert.equal(typeof server.listen, 'function');

  await new Promise(resolve => server.listen(0, '127.0.0.1', resolve));
  const addr = server.address();
  assert.ok(addr && typeof addr === 'object' && typeof addr.port === 'number');
  const baseUrl = `http://127.0.0.1:${addr.port}`;
  return { server, baseUrl };
}

async function requestJson(url, init) {
  const res = await fetch(url, init);
  const text = await res.text();
  let json = null;
  if (text.trim()) {
    try {
      json = JSON.parse(text);
    } catch {
      throw new Error(`Expected JSON response, got: ${text.slice(0, 200)}`);
    }
  }
  return { res, json, text };
}

test('GET /health + GET /openapi.json', async () => {
  const dir = makeTempDir();
  const dataPath = path.join(dir, 'db.json');
  const { server, baseUrl } = await startServer(dataPath);
  try {
    const health = await requestJson(`${baseUrl}/health`);
    assert.equal(health.res.status, 200);
    assert.equal(health.json.ok, true);

    const spec = await requestJson(`${baseUrl}/openapi.json`);
    assert.equal(spec.res.status, 200);
    assert.equal(typeof spec.json.openapi, 'string');
    assert.ok(spec.json.openapi.startsWith('3.'));
    assert.ok(spec.json.paths && typeof spec.json.paths === 'object');
    assert.ok(spec.json.paths['/todos']);
  } finally {
    await new Promise(resolve => server.close(resolve));
  }
});

test('Todo CRUD + persistence', async () => {
  const dir = makeTempDir();
  const dataPath = path.join(dir, 'db.json');
  const { server, baseUrl } = await startServer(dataPath);
  try {
    // create
    const created = await requestJson(`${baseUrl}/todos`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ title: 'Buy milk' }),
    });
    assert.equal(created.res.status, 201, created.text);
    assert.equal(created.json.ok, true);
    const id = String(created.json.todo.id);
    assert.ok(id.length > 0);
    assert.equal(created.json.todo.title, 'Buy milk');
    assert.equal(created.json.todo.done, false);
    assert.equal(typeof created.json.todo.createdAt, 'string');

    // list
    const list1 = await requestJson(`${baseUrl}/todos`);
    assert.equal(list1.res.status, 200);
    assert.equal(list1.json.ok, true);
    assert.ok(Array.isArray(list1.json.todos));
    assert.equal(list1.json.todos.length, 1);
    assert.equal(String(list1.json.todos[0].id), id);

    // get
    const get1 = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`);
    assert.equal(get1.res.status, 200);
    assert.equal(get1.json.ok, true);
    assert.equal(String(get1.json.todo.id), id);

    // done
    const done = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ done: true }),
    });
    assert.equal(done.res.status, 200, done.text);
    assert.equal(done.json.ok, true);
    assert.equal(done.json.todo.done, true);
    assert.equal(typeof done.json.todo.doneAt, 'string');

    // file persistence check (after done)
    assert.ok(fs.existsSync(dataPath));
    const persisted1 = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    assert.ok(Array.isArray(persisted1.todos));
    assert.equal(persisted1.todos.length, 1);
    assert.equal(String(persisted1.todos[0].id), id);
    assert.equal(Boolean(persisted1.todos[0].done), true);

    // delete
    const del = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`, { method: 'DELETE' });
    assert.equal(del.res.status, 200, del.text);
    assert.equal(del.json.ok, true);

    const list2 = await requestJson(`${baseUrl}/todos`);
    assert.equal(list2.res.status, 200);
    assert.equal(list2.json.ok, true);
    assert.equal(list2.json.todos.length, 0);

    const persisted2 = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    assert.ok(Array.isArray(persisted2.todos));
    assert.equal(persisted2.todos.length, 0);

    // 404 cases
    const missing = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`);
    assert.equal(missing.res.status, 404);
    assert.equal(missing.json.ok, false);

    const badCreate = await requestJson(`${baseUrl}/todos`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({}),
    });
    assert.equal(badCreate.res.status, 400);
    assert.equal(badCreate.json.ok, false);
  } finally {
    await new Promise(resolve => server.close(resolve));
  }
});
--- END ORACLE TESTS ---

VYSTUPNI FORMAT (STRICT): vrat JEN JSON objekt tohoto tvaru:
{
  "mode": "full",
  "files": [
    {"path": "README.md", "content": "...\n"},
    {"path": "package.json", "content": "...\n"},
    {"path": "openapi.json", "content": "...\n"},
    {"path": "src/server.js", "content": "...\n"}
  ],
  "notes": "optional"
}

Pravidla:
- Zadny markdown, zadne ``` bloky, zadny text mimo JSON.
- Cesty jsou relativni, pouzij `/`, bez `..` a bez absolutnich cest.
- Nezahrnuj vlastni `tests/` (pouziji se oracle testy).
- `content` je vzdy kompletni obsah souboru (ne diff/snippet).
- `package.json` dej minimalni a nastav "type":"commonjs".

---
PLAN (planner: deepseek-r1:8b):
We are creating a Node.js project with the following structure:

- mode: "full"
- files: an array of objects with "path" and "content"
- notes: optional

Steps:
1. Create a `package.json` with minimal dependencies and set "type":"commonjs".
2. Create a `src/server.js` that exports a function `createServer` which returns a server that handles the endpoints.
3. Create an `openapi.json` file that defines the OpenAPI 3.x specification for the TODO endpoints.
4. Create a `README.md` with a brief description.

---
NEPROSLO VALIDACI. Oprav nasledujici problemy.

CHYBY:
- src/server.js must export createServer (e.g. module.exports = { createServer })
- openapi.json missing "/openapi.json" path
- Command failed: node --test tests/oracle.test.js (exit=1, timedOut=false)
- src/server.js must export createServer (oracle assertion)

HARD CHECKLIST (NODE API):
- V `mode:"full"` zahrn README.md, package.json, openapi.json, src/server.js.
- Zadny express/fastify/externi balicky. Pouze Node builtin.
- `src/server.js` musi mit `function createServer({ dataPath }) { ... }` a `module.exports = { createServer };`
- `createServer` NESMI volat `listen()`; jen vrat `http.createServer(...)`.
- openapi.json musi mit /health, /openapi.json, /todos, /todos/{id} + GET/POST/PATCH/DELETE.
- Pri cteni db/openapi osetri neexistujici soubor (`existsSync` fallback).

DULEZITE (NODE API): `src/server.js` musi exportovat `createServer` jako objekt:
- `function createServer({ dataPath }) { ... return server; }`
- `module.exports = { createServer };` (NE `module.exports = createServer`).

DULEZITE (OPENAPI): Spec musi mit paths: /health, /openapi.json, /todos, /todos/{id} a metody GET/POST/PATCH/DELETE dle zadani.

LOGY (zkraceno):
- node --test tests/oracle.test.js
  stdout: "r [ERR_ASSERTION]: src/server.js must export createServer\n  + actual - expected\n  \n  + 'undefined'\n  - 'function'\n  \n      at startServer (C:\\Users\\atrep\\Desktop\\Test_AI_Code\\shumilek\\projects\\bot_eval_run\\batch_1771763807099\\node-api-oracle_run_09\\workspace\\tests\\oracle.test.js:14:10)\n      at TestContext.<anonymous> (C:\\Users\\atrep\\Desktop\\Test_AI_Code\\shumilek\\projects\\bot_eval_run\\batch_1771763807099\\node-api-oracle_run_09\\workspace\\tests\\oracle.test.js:42:37)\n      at Test.runInAsyncScope (node:async_hooks:214:14)\n      at Test.run (node:internal/test_runner/test:1106:25)\n      at Test.start (node:internal/test_runner/test:1003:17)\n      at startSubtestAfterBootstrap (node:internal/test_runner/harness:358:17) {\n    generatedMessage: false,\n    code: 'ERR_ASSERTION',\n    actual: 'undefined',\n    expected: 'function',\n    operator: 'strictEqual',\n    diff: 'simple'\n  }\n\ntest at tests\\oracle.test.js:59:1\n✖ Todo CRUD + persistence (0.6678ms)\n  AssertionError [ERR_ASSERTION]: src/server.js must export createServer\n  + actual - expected\n  \n  + 'undefined'\n  - 'function'\n  \n      at startServer (C:\\Users\\atrep\\Desktop\\Test_AI_Code\\shumilek\\projects\\bot_eval_run\\batch_1771763807099\\node-api-oracle_run_09\\workspace\\tests\\oracle.test.js:14:10)\n      at TestContext.<anonymous> (C:\\Users\\atrep\\Desktop\\Test_AI_Code\\shumilek\\projects\\bot_eval_run\\batch_1771763807099\\node-api-oracle_run_09\\workspace\\tests\\oracle.test.js:62:37)\n      at Test.runInAsyncScope (node:async_hooks:214:14)\n      at Test.run (node:internal/test_runner/test:1106:25)\n      at Test.processPendingSubtests (node:internal/test_runner/test:788:18)\n      at Test.postRun (node:internal/test_runner/test:1235:19)\n      at Test.run (node:internal/test_runner/test:1163:12)\n      at async startSubtestAfterBootstrap (node:internal/test_runner/harness:358:3) {\n    generatedMessage: false,\n    code: 'ERR_ASSERTION',\n    actual: 'undefined',\n    expected: 'function',\n    operator: 'strictEqual',\n    diff: 'simple'\n  }\n"

AKTUALNI SOUBORY:
- README.md
- openapi.json
- package.json
- src/server.js
- tests/oracle.test.js

KONTEXT SOUBORU (pro opravu):
--- FILE: src/server.js ---
// src/server.js
const http = require('http');
const fs = require('fs');
const path = require('path');

function createServer(dataPath) {
  const server = http.createServer((req, res) => {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });

    req.on('end', () => {
      if (req.method === 'GET' && req.url === '/health') {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ status: 'healthy' }));
      } else if (req.method === 'GET' && req.url === '/todos') {
        fs.readFile(dataPath, 'utf8', (err, data) => {
          if (err) {
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Internal Server Error' }));
          } else {
            const todos = JSON.parse(data || '[]');
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ todos }));
          }
        });
      } else if (req.method === 'POST' && req.url === '/todos') {
        const todo = JSON.parse(body);
        fs.readFile(dataPath, 'utf8', (err, data) => {
          let todos = JSON.parse(data || '[]');
          todo.id = Date.now().toString();
          todo.done = false;
          todos.push(todo);
          fs.writeFile(dataPath, JSON.stringify(todos), err => {
            if (err) {
              res.writeHead(500, { 'Content-Type': 'application/json' });
              res.end(JSON.stringify({ error: 'Internal Server Error' }));
            } else {
              res.writeHead(201, { 'Content-Type': 'application/json' });
              res.end(JSON.stringify(todo));
            }
          });
        });
      } else if (req.method === 'GET' && req.url.startsWith('/todos/')) {
        const id = req.url.split('/')[2];
        fs.readFile(dataPath, 'utf8', (err, data) => {
          const todos = JSON.parse(data || '[]');
          const todo = todos.find(t => t.id === id);
          if (todo) {
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(todo));
          } else {
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Not Found' }));
          }
        });
      } else if (req.method === 'PATCH' && req.url.startsWith('/todos/')) {
        const id = req.url.split('/')[2];
        const update = JSON.parse(body);
        fs.readFile(dataPath, 'utf8', (err, data) => {
          let todos = JSON.parse(data || '[]');
          const todoIndex = todos.findIndex(t => t.id === id);
          if (todoIndex !== -1) {
            todos[todoIndex].done = update.done;
            fs.writeFile(dataPath, JSON.stringify(todos), err => {
              if (err) {
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'Internal Server Error' }));
              } else {
                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify(todos[todoIndex]));
              }
            });
          } else {
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Not Found' }));
          }
        });
      } else if (req.method === 'DELETE' && req.url.startsWith('/todos/')) {
        const id = req.url.split('/')[2];
        fs.readFile(dataPath, 'utf8', (err, data) => {
          let todos = JSON.parse(data || '[]');
          const todoIndex = todos.findIndex(t => t.id === id);
          if (todoIndex !== -1) {
            todos.splice(todoIndex, 1);
            fs.writeFile(dataPath, JSON.stringify(todos), err => {
              if (err) {
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'Internal Server Error' }));
              } else {
                res.writeHead(204);
                res.end();
              }
            });
          } else {
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Not Found' }));
          }
        });
      } else {
        res.writeHead(404, { 'Content-Type': 'text/plain' });
        res.end('Not Found');
      }
    });
  });

  return server;
}

module.exports = createServer;
--- FILE: openapi.json ---
{
  "openapi": "3.0.0",
  "info": {
    "title": "TODO API",
    "version": "1.0.0"
  },
  "paths": {
    "/health": {
      "get": {
        "summary": "Check the health of the server",
        "responses": {
          "200": {
            "description": "Server is healthy",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/todos": {
      "get": {
        "summary": "Retrieve all TODO items",
        "responses": {
          "200": {
            "description": "A list of TODO items",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TodoList"
                }
              }
            }
          }
        }
      },
      "post": {
        "summary": "Create a new TODO item",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Todo"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "The created TODO item",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Todo"
                }
              }
            }
          }
        }
      }
    },
    "/todos/{id}": {
      "get": {
        "summary": "Retrieve a specific TODO item by ID",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The TODO item",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Todo"
                }
              }
            }
          },
          "404": {
            "description": "TODO item not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "patch": {
        "summary": "Update a specific TODO item by marking it as done",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TodoUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The updated TODO item",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Todo"
                }
              }
            }
          },
          "404": {
            "description": "TODO item not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "summary": "Delete a specific TODO item by ID",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "TODO item deleted successfully"
          },
          "404": {
            "description": "TODO item not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "TodoList": {
        "type": "object",
        "properties": {
          "todos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Todo"
            }
          }
        }
      },
      "Todo": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "done": {
            "type": "boolean"
          }
        },
        "required": ["id", "title", "done"]
      },
      "TodoUpdate": {
        "type": "object",
        "properties": {
          "done": {
            "type": "boolean"
          }
        },
        "required": ["done"]
      },
      "Error": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string"
          }
        }
      }
    }
  }
}

VYSTUP: vrat JEN platny JSON objekt bez markdownu:
{ "mode": "patch", "files": [ {"path":"...","content":"...\n"} ], "notes": "optional" }
Pravidla: udelej jen minimalni nutne zmeny; posli jen soubory ktere menis nebo pridavas; u kazdeho posli VZDY cely obsah souboru.