Jsi code reviewer (mini-validator). Tvuj ukol: navrhnout MINIMALNI opravy, ktere povedou k tomu, ze validace projde.
Odpovez JEN JSON bez markdownu: { "review": "text", "priorityFiles": ["path1","path2"] }

SPEC (zkraceno):
Vytvor realisticky Node.js projekt (bez externich zavislosti), ktery poskytuje REST API pro TODO a projde oracle testy.

POZADAVKY / KONTRAKT:
- Zadne externi npm balicky. Pouze Node.js builtin moduly.
- Kód bude v `src/` a bude CommonJS (require/module.exports).
- Soubor `src/server.js` musi exportovat funkci `createServer({ dataPath })`.
- Server musi poskytovat endpointy:
  - GET /health -> 200 JSON { ok: true }
  - GET /openapi.json -> 200 JSON OpenAPI 3.x (musí obsahovat paths pro /todos)
  - GET /todos -> 200 JSON { ok: true, todos: [...] }
  - POST /todos (body {title}) -> 201 JSON { ok: true, todo }
  - GET /todos/:id -> 200 JSON { ok:true, todo } nebo 404 JSON { ok:false, error }
  - PATCH /todos/:id (body {done:true}) -> 200 JSON { ok:true, todo }
  - DELETE /todos/:id -> 200 JSON { ok:true }
- Persistuj do souboru `dataPath` jako JSON { "todos": [...] } po kazde mutaci.

Poznamka: testy budeme pouzivat tyto (musis projit):
--- BEGIN ORACLE TESTS (tests/oracle.test.js) ---
const test = require('node:test');
const assert = require('node:assert/strict');
const fs = require('node:fs');
const path = require('node:path');
const os = require('node:os');

function makeTempDir() {
  return fs.mkdtempSync(path.join(os.tmpdir(), 'bot-eval-node-api-'));
}

async function startServer(dataPath) {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const mod = require('../src/server.js');
  assert.equal(typeof mod.createServer, 'function', 'src/server.js must export createServer');
  const server = mod.createServer({ dataPath });
  assert.equal(typeof server.listen, 'function');

  await new Promise(resolve => server.listen(0, '127.0.0.1', resolve));
  const addr = server.address();
  assert.ok(addr && typeof addr === 'object' && typeof addr.port === 'number');
  const baseUrl = `http://127.0.0.1:${addr.port}`;
  return { server, baseUrl };
}

async function requestJson(url, init) {
  const res = await fetch(url, init);
  const text = await res.text();
  let json = null;
  if (text.trim()) {
    try {
      json = JSON.parse(text);
    } catch {
      throw new Error(`Expected JSON response, got: ${text.slice(0, 200)}`);
    }
  }
  return { res, json, text };
}

test('GET /health + GET /openapi.json', async () => {
  const dir = makeTempDir();
  const dataPath = path.join(dir, 'db.json');
  const { server, baseUrl } = await startServer(dataPath);
  try {
    const health = await requestJson(`${baseUrl}/health`);
    assert.equal(health.res.status, 200);
    assert.equal(health.json.ok, true);

    const spec = await requestJson(`${baseUrl}/openapi.json`);
    assert.equal(spec.res.status, 200);
    assert.equal(typeof spec.json.openapi, 'string');
    assert.ok(spec.json.openapi.startsWith('3.'));
    assert.ok(spec.json.paths && typeof spec.json.paths === 'object');
    assert.ok(spec.json.paths['/todos']);
  } finally {
    await new Promise(resolve => server.close(resolve));
  }
});

test('Todo CRUD + persistence', async () => {
  const dir = makeTempDir();
  const dataPath = path.join(dir, 'db.json');
  const { server, baseUrl } = await startServer(dataPath);
  try {
    // create
    const created = await requestJson(`${baseUrl}/todos`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ title: 'Buy milk' }),
    });
    assert.equal(created.res.status, 201, created.text);
    assert.equal(created.json.ok, true);
    const id = String(created.json.todo.id);
    assert.ok(id.length > 0);
    assert.equal(created.json.todo.title, 'Buy milk');
    assert.equal(created.json.todo.done, false);
    assert.equal(typeof created.json.todo.createdAt, 'string');

    // list
    const list1 = await requestJson(`${baseUrl}/todos`);
    assert.equal(list1.res.status, 200);
    assert.equal(list1.json.ok, true);
    assert.ok(Array.isArray(list1.json.todos));
    assert.equal(list1.json.todos.length, 1);
    assert.equal(String(list1.json.todos[0].id), id);

    // get
    const get1 = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`);
    assert.equal(get1.res.status, 200);
    assert.equal(get1.json.ok, true);
    assert.equal(String(get1.json.todo.id), id);

    // done
    const done = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ done: true }),
    });
    assert.equal(done.res.status, 200, done.text);
    assert.equal(done.json.ok, true);
    assert.equal(done.json.todo.done, true);
    assert.equal(typeof done.json.todo.doneAt, 'string');

    // file persistence check (after done)
    assert.ok(fs.existsSync(dataPath));
    const persisted1 = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    assert.ok(Array.isArray(persisted1.todos));
    assert.equal(persisted1.todos.length, 1);
    assert.equal(String(persisted1.todos[0].id), id);
    assert.equal(Boolean(persisted1.todos[0].done), true);

    // delete
    const del = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`, { method: 'DELETE' });
    assert.equal(del.res.status, 200, del.text);
    assert.equal(del.json.ok, true);

    const list2 = await requestJson(`${baseUrl}/todos`);
    assert.equal(list2.res.status, 200);
    assert.equal(list2.json.ok, true);
    assert.equal(list2.json.todos.length, 0);

    const persisted2 = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    assert.ok(Array.isArray(persisted2.todos));
    assert.equal(persisted2.todos.length, 0);

    // 404 cases
    const missing = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`);
    assert.equal(missing.res.status, 404);
    assert.equal(missing.json.ok, false);

    const badCreate = await requestJson(`${baseUrl}/todos`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({}),
    });
    assert.equal(badCreate.res.status, 400);
    assert.equal(badCreate.json.ok, false);
 
...<snip>...


CHYBY:
- Command failed: node --test tests/oracle.test.js (exit=1, timedOut=false)

LOGY (zkraceno):
- node --test tests/oracle.test.js
  stdout: ",\n  path: 'C:\\\\Users\\\\atrep\\\\AppData\\\\Local\\\\Temp\\\\bot-eval-node-api-AipERl\\\\db.json'\n}\n✖ GET /health + GET /openapi.json (27.7871ms)\n✖ Todo CRUD + persistence (5.4834ms)\nℹ tests 2\nℹ suites 0\nℹ pass 0\nℹ fail 2\nℹ cancelled 0\nℹ skipped 0\nℹ todo 0\nℹ duration_ms 303198.8953\n\n✖ failing tests:\n\ntest at tests\\oracle.test.js:39:1\n✖ GET /health + GET /openapi.json (27.7871ms)\n  TypeError: Class constructor URL cannot be invoked without 'new'\n      at Server.<anonymous> (C:\\Users\\atrep\\Desktop\\Test_AI_Code\\shumilek\\projects\\bot_eval_run\\run_1768573044209\\workspace\\src\\server.js:38:27)\n      at Server.emit (node:events:508:28)\n      at parserOnIncoming (node:_http_server:1210:12)\n      at HTTPParser.parserOnHeadersComplete (node:_http_common:123:17)\n\ntest at tests\\oracle.test.js:59:1\n✖ Todo CRUD + persistence (5.4834ms)\n  TypeError: Class constructor URL cannot be invoked without 'new'\n      at Server.<anonymous> (C:\\Users\\atrep\\Desktop\\Test_AI_Code\\shumilek\\projects\\bot_eval_run\\run_1768573044209\\workspace\\src\\server.js:38:27)\n      at Server.emit (node:events:508:28)\n      at parserOnIncoming (node:_http_server:1210:12)\n      at HTTPParser.parserOnHeadersComplete (node:_http_common:123:17)\n"

SOUBORY (zkraceno):
- README.md
- openapi.json
- package.json
- src/server.js
- tests/oracle.test.js

KONTEXT SOUBORU (zkraceno):
--- FILE: src/server.js ---
const http = require('http');
const fs = require('fs');
const url = require('url');

function createServer({ dataPath }) {
  let todos = [];
  try {
    const rawData = fs.readFileSync(dataPath, 'utf8');
    if (rawData) {
      const parsedData = JSON.parse(rawData);
      if (Array.isArray(parsedData.todos)) {
        todos = parsedData.todos;
      }
    }
  } catch (err) {
    console.warn('Error reading or parsing data file:', err);
  }

  function saveTodos() {
    fs.writeFileSync(dataPath, JSON.stringify({ todos }), 'utf8');
  }

  function parseBody(req) {
    return new Promise((resolve) => {
      let body = '';
      req.on('data', chunk => (body += chunk));
      req.on('end', () => {
        try {
          resolve(JSON.parse(body));
        } catch (e) {
          resolve(null);
        }
      });
    });
  }

  return http.createServer(async (req, res) => {
    const parsedUrl = url.URL(req.url, `http://${req.headers.host}/`);
    const pathName = parsedUrl.pathname;
    const query = parsedUrl.searchParams;
    let id;

    if (pathName.includes('/todos/')) {
      [, id] = pathName.split('/todos/');
    }

    res.setHeader('Content-Type', 'application/json');

    switch (`${req.method}-${pathName}`) {
      case 'GET-/health':
        res.writeHead(200);
        res.end(JSON.stringify({ ok: true }));
        break;
      case 'GET-/openapi.json':
        fs.readFile('openapi.json', (err, data) => {
          if (err) {
            res.writeHead(500);
            res.end(JSON.stringify({ error: 'OpenAPI file not found' }));
          } else {
            res.setHeader('Content-Type', 'application/json');
            res.writeHead(200);
            res.end(data);
          }
        });
        break;
      case 'GET-/todos':
        res.writeHead(200);
        res.end(JSON.stringify({ ok: true, todos }));
        break;
      case `GET-/todos/${id}`:
        const todo = todos.find(t => t.id === id);
        if (todo) {
          res.writeHead(200);
          res.end(JSON.stringify({ ok: true, todo }));
        } else {
          res.writeHead(404);
          res.end(JSON.stringify({ ok: false, error: 'Todo not found' }));
        }
        break;
      case 'POST-/todos':
        const newTodo = await parseBody(req);
        if (!newTodo || typeof newTodo.title !== 'string') {
          res.writeHead(400);
          res.end(JSON.stringify({ ok: false, error: 'Invalid todo format' }));
        } else {
          const createdTodo = { id: Date.now().toString(), title: newTodo.title, done: false, createdAt: new Date().toISOString() };
          todos.push(createdTodo);
          saveTodos();
          res.writeHead(201);
          res.end(JSON.stringify({ ok: true, todo: createdTodo }));
        }
        break;
      case `PATCH-/todos/${id}`:
        const updatedData = await parseBody(req);
        const index = todos.findIndex(t => t.id === id);
        if (index >= 0) {
          if (updatedData.done !== undefined && typeof updatedData.done === 'boolean') {
            todos[index].done = updatedData.done;
          }
          saveTodos();
          res.writeHead(200);
          res.end(JSON.stringify({ ok: true, todo: todos[index] }));
        } else {
          res.writeHead(404);
          res.end(JSON.stringify({ ok: false, error: 'Todo not found' }));
        }
        break;
      case `DELETE-/todos/${id}`:
        const deleteIndex = todos.findIndex(t => t.id === id);
        if (deleteIndex >= 0) {
          todos.splice(deleteIndex, 1);
          saveTodos();
          res.writeHead(200);
          res.end(JSON.stringify({ ok: true }));
        } else {
          res.writeHead(404);
          res.end(JSON.stringify({ ok: false, error: 'Todo not found' }));
        }
        break;
      default:
        res.writeHead(404);
        res.end(JSON.stringify({ ok: false, error: 'Not Found' }));
    }
  });
}

module.exports = { createServer };

--- FILE: tests/oracle.test.js ---
const test = require('node:test');
const assert = require('node:assert/strict');
const fs = require('node:fs');
const path = require('node:path');
const os = require('node:os');

function makeTempDir() {
  return fs.mkdtempSync(path.join(os.tmpdir(), 'bot-eval-node-api-'));
}

async function startServer(dataPath) {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const mod = require('../src/server.js');
  assert.equal(typeof mod.createServer, 'function', 'src/server.js must export createServer');
  const server = mod.createServer({ dataPath });
  assert.equal(typeof server.listen, 'function');

  await new Promise(resolve => server.listen(0, '127.0.0.1', resolve));
  const addr = server.address();
  assert.ok(addr && typeof addr === 'object' && typeof addr.port === 'number');
  const baseUrl = `http://127.0.0.1:${addr.port}`;
  return { server, baseUrl };
}

async function requestJson(url, init) {
  const res = await fetch(url, init);
  const text = await res.text();
  let json = null;
  if (text.trim()) {
    try {
      json = JSON.parse(text);
    } catch {
      throw new Error(`Expected JSON response, got: ${text.slice(0, 200)}`);
    }
  }
  return { res, json, text };
}

test('GET /health + GET /openapi.json', async () => {
  const dir = makeTempDir();
  const dataPath = path.join(dir, 'db.json');
  const { server, baseUrl } = await startServer(dataPath);
  try {
    const health = await requestJson(`${baseUrl}/health`);
    assert.equal(health.res.status, 200);
    assert.equal(health.json.ok, true);

    const spec = await requestJson(`${baseUrl}/openapi.json`);
    assert.equal(spec.res.status, 200);
    assert.equal(typeof spec.json.openapi, 'string');
    assert.ok(spec.json.openapi.startsWith('3.'));
    assert.ok(spec.json.paths && typeof spec.json.paths === 'object');
    assert.ok(spec.json.paths['/todos']);
  } finally {
    await new Promise(resolve => server.close(resolve));
  }
});

test('Todo CRUD + persistence', async () => {
  const dir = makeTempDir();
  const dataPath = path.join(dir, 'db.json');
  const { server, baseUrl } = await startServer(dataPath);
  try {
    // create
    const created = await requestJson(`${baseUrl}/todos`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ title: 'Buy milk' }),
    });
    assert.equal(created.res.status, 201, created.text);
    assert.equal(created.json.ok, true);
    const id = String(created.json.todo.id);
    assert.ok(id.length > 0);
    assert.equal(created.json.todo.title, 'Buy milk');
    assert.equal(created.json.todo.done, false);
    assert.equal(typeof created.json.todo.createdAt, 'string');

    // list
    const list1 = await requestJson(`${baseUrl}/todos`);
    assert.equal(list1.res.status, 200);
    assert.equal(list1.json.ok, true);
    assert.ok(Array.isArray(list1.json.todos));
    assert.equal(list1.json.todos.length, 1);
    assert.equal(String(list1.json.todos[0].id), id);

    // get
    const get1 = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`);
    assert.equal(get1.res.status, 200);
    assert.equal(get1.json.ok, true);
    assert.equal(String(get1.json.todo.id), id);

    // done
    const done = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ done: true }),
    });
    assert.equal(done.res.status, 200, done.text);
    assert.equal(done.json.ok, true);
    assert.equal(done.json.todo.done, true);
    assert.equal(typeof done.json.todo.doneAt, 'string');

    // file persistence check (after done)
    assert.ok(fs.existsSync(dataPath));
    const persisted1 = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    assert.ok(Array.isArray(persisted1.todos));
    assert.equal(persisted1.todos.length, 1);
    assert.equal(String(persisted1.todos[0].id), id);
    assert.equal(Boolean(persisted1.todos[0].done), true);

    // d
...<snip>...
