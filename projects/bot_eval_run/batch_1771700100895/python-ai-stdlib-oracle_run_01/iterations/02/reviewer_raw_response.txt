{
  "mode": "full",
  "files": [
    {"path": "README.md"},
    {"path": "mini_ai/__init__.py", "content": "from .markov import MarkovChain\n"},
    {"path": "mini_ai/markov.py", "content": "\nimport json\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions = {}\n\n    @property\n    def order(self) -> int:\n        return self._order\n\n    @order.setter\n    def order(self, value: int):\n        if not isinstance(value, int) or value <= 0:\n            raise ValueError('Order must be a positive integer')\n        self._order = value\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order + 1):\n            context = text[i:i+self.order]\n            next_char = text[i+self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {}\n            if next_char not in self.transitions[context]:\n                self.transitions[context][next_char] = 0\n            self.transitions[context][next_char] += 1\n\n    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\n        if not isinstance(length, int) or length <= 0:\n            raise ValueError('Length must be a positive integer')\n        context = self._generate_context(seed, random_seed)\n        result = [context]\n        for _ in range(length - 1):\n            next_char = max(self.transitions[context], key=lambda x: self.transitions[context][x])\n            result.append(next_char)\n            context = (result[-self.order:] if len(result) >= self.order else result[-1:])\n        return ''.join(result)\n\n    def _generate_context(self, seed: str | None, random_seed: int | None) -> str:\n        import random\n        if seed is not None and isinstance(seed, str):\n            context = seed[:self.order]\n        elif random_seed is not None and isinstance(random_seed, int):\n            random.seed(random_seed)\n            context = ''.join(chr(ord('a') + random.randint(0, 25)) for _ in range(self.order))\n        else:\n            context = ''.join(chr(ord('a') + random.randint(0, 25)) for _ in range(self.order))\n        return context\n\n    def to_dict(self) -> dict:\n        return {\n            'order': self.order,\n            'transitions': self.transitions\n        }\n\n    @classmethod\n    def from_dict(cls, d: dict):\n        mc = cls(d['order'])\n        mc.transitions = d['transitions']\n        return mc"},
    {"path": "mini_ai/cli.py", "content": "\nimport argparse\nfrom .markov import MarkovChain\n\nparser = argparse.ArgumentParser()\nsubparsers = parser.add_subparsers(dest='command')\n\ntrain_parser = subparsers.add_parser('train', help='Train a Markov chain model from input text and save it to a JSON file.')\ntrain_parser.add_argument('--input', type=str, required=True, help='Input text file path for training the model.')\ntrain_parser.add_argument('--model-out', type=str, required=True, help='Output JSON file path for saving the trained model.')\ntrain_parser.add_argument('--order', type=int, default=1, help='Order of Markov chain (default: 1).')\n\ntrain_parser.set_defaults(func=lambda args: _run_train(args))\n\n@MarkovChain.from_dict.register\ndef from_dict(cls, d):\n    return cls(d['order'])\n\n@classmethod\nasync def from_dict(cls, d):\n    return cls(d['order'])\n\n@train_parser.command\nasync def func(args):\n    with open(args.input, 'r', encoding='utf-8') as f:\n        text = f.read()\n    mc = MarkovChain(order=args.order)\n    mc.train(text)\n    with open(args.model_out, 'w', encoding='utf-8') as f:\n        json.dump(mc.to_dict(), f, ensure_ascii=False, indent=4)\n\n@subparsers.add_parser('generate', help='Generate text using a trained Markov chain model.')\n@MarkovChain.from_dict.register\ndef generate(cls):\n    parser.add_argument('--model', type=str, required=True, help='Model JSON file path to load the trained Markov chain model.')\n    parser.add_argument('--length', type=int, required=True, help='Length of generated text (default: 10).')\n    parser.add_argument('--seed', type=str, help='Seed for deterministic generation. If not provided, a random seed will be used.')\n    parser.add_argument('--random-seed', type=int, help='Random seed for deterministic generation. If not provided, a new random seed will be generated.')\n\n@generate.set_defaults(func=lambda args: _run_generate(args))\n\nasync def func(args):\n    mc = MarkovChain.from_dict(await cls.from_dict.load_from_file(args.model))\n    result = mc.generate(length=args.length)\n    if args.seed is not None:\n        seed = args.seed.encode('utf-8')\n    elif args.random_seed is not None:\n        random.seed(args.random_seed)\n        seed = str(random.randint(0, 10000)).encode('utf-8')\n    else:\n        seed = os.urandom(4).hex().encode('utf-8')\n    result = result[:args.length]\n    print(result.decode('utf-8'))"},
    {"path": "mini_ai/__init__.py", "content": "}\n"}
  ],
  "notes": "README.md should be created with basic instructions and usage examples. Ensure that the CLI commands are correctly implemented and tested."
}