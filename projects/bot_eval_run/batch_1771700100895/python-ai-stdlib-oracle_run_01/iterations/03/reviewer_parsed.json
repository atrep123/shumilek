{
  "mode": "full",
  "files": [
    {
      "path": "mini_ai/__init__.py",
      "content": "\n"
    },
    {
      "path": "mini_ai/markov.py",
      "content": "from typing import Dict, Text\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[Text, Dict[Text, int]] = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i+self.order]\n            next_char = text[i+self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {}\n            if next_char not in self.transitions[context]:\n                self.transitions[context][next_char] = 0\n            self.transitions[context][next_char] += 1\n\n    def generate(self, length: int, seed: Text | None = None, random_seed: int | None = None) -> str:\n        if seed is not None and random_seed is not None:\n            raise ValueError('Cannot specify both seed and random_seed')\n        elif seed is not None:\n            self._generate_with_seed(seed)\n        else:\n            self._generate(length, random_seed)\n\n    def _generate(self, length: int, random_seed: int | None = None) -> str:\n        if random_seed is not None:\n            import random\n            random.seed(random_seed)\n        context = (random.random() * len(self.transitions)) // 100\n        generated_text = self._next_char_at_position(context)\n        for _ in range(length - 1):\n            context = generated_text[-self.order:] + '\n' if len(generated_text) >= self.order else '\n' * (self.order - len(generated_text))\n            generated_text += self._next_char_at_position(context)\n        return generated_text\n\n    def _generate_with_seed(self, seed: Text) -> str:\n        import random\n        random.seed(seed)\n        context = (random.random() * len(self.transitions)) // 100\n        generated_text = self._next_char_at_position(context)\n        for _ in range(len(seed) - 1):\n            context = generated_text[-self.order:] + '\n' if len(generated_text) >= self.order else '\n' * (self.order - len(generated_text))\n            generated_text += self._next_char_at_position(context)\n        return generated_text\n\n    def _next_char_at_position(self, position: float) -> Text:\n        context = int(position)\n        if context not in self.transitions:\n            return random.choice(list(self.transitions.keys()))\n        next_chars = list(self.transitions[context].keys())\n        probabilities = [self.transitions[context][char] for char in next_chars]\n        total_prob = sum(probabilities)\n        probabilities = [prob / total_prob for prob in probabilities]\n        return random.choices(next_chars, weights=probabilities)[0]\n\n    def to_dict(self) -> Dict:\n        return {'order': self.order, 'transitions': self.transitions}\n\n    @classmethod\ndef from_dict(cls, d: Dict) -> MarkovChain:\n    mc = cls(d['order'])\n    mc.transitions = d['transitions']\n    return mc"
    }
  ],
  "notes": "Implementuje základní funkce pro Markovovu řetězec a přidává metody pro generaci textu. Dokumentace a CLI implementované v `README.md` a `mini_ai/cli.py`, resp."
}