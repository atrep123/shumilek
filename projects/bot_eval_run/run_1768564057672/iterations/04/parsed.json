{
  "mode": "patch",
  "files": [
    {
      "path": "mini_ai/markov.py",
      "content": "class MarkovChain(object):\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {next_char: 1}\n            else:\n                if next_char in self.transitions[context]:\n                    self.transitions[context][next_char] += 1\n                else:\n                    self.transitions[context][next_char] = 1\n\n    def to_dict(self) -> dict:\n        return {\"order\": self.order, \"transitions\": self.transitions}\n\n    def generate(self, length: int, seed: str = None, random_seed: int = None) -> str:\n        import random\n        if seed is None:\n            seed = list(self.transitions.keys())[0][:self.order]\n        result = seed\n        for _ in range(length - self.order):\n            context = result[-self.order:]\n            possible_chars = list(self.transitions[context].keys())\n            weights = [self.transitions[context][c] for c in possible_chars]\n            next_char = random.choices(possible_chars, weights=weights)[0]\n            result += next_char\n        return result\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nimport json\nfrom mini_ai.markov import MarkovChain\n\ndef main(argv=None):\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers(dest='command')\n\n    train_parser = subparsers.add_parser('train')\n    train_parser.add_argument('--input', type=str, required=True)\n    train_parser.add_argument('--model-out', type=str, required=True)\n    train_parser.add_argument('--order', type=int, required=True)\n\n    generate_parser = subparsers.add_parser('generate')\n    generate_parser.add_argument('--model', type=str, required=True)\n    generate_parser.add_argument('--length', type=int, required=True)\n    generate_parser.add_argument('--seed', type=str, default=None)\n    generate_parser.add_argument('--random-seed', type=int, default=None)\n\n    args = parser.parse_args(argv)\n\n    if args.command == 'train':\n        mc = MarkovChain(order=args.order)\n        with open(args.input, 'r') as f:\n            text = f.read()\n        mc.train(text)\n        with open(args.model_out, 'w') as f:\n            json.dump(mc.to_dict(), f)\n    elif args.command == 'generate':\n        with open(args.model, 'r') as f:\n            model_data = json.load(f)\n        mc = MarkovChain.from_dict(model_data)\n        generated_text = mc.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\n        print(generated_text)\n    return 0\n"
    }
  ]
}