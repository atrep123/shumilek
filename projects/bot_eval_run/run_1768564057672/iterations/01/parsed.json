{
  "mode": "full",
  "files": [
    {
      "path": "README.md",
      "content": "# Mini AI Project\n\nThis project is a simple implementation of a character-level Markov chain generator in Python.\n\n## Features\n\n- Uses only standard library Python modules (no numpy, pandas, sklearn, torch, tensorflow, requests).\n- Implements a MarkovChain class with methods for training and generating text based on the model.\n- Provides a CLI interface to train the model from a text file and generate new text using the trained model.\n\n## Installation\n\n1. Clone this repository: `git clone <repository_url>`\n2. Navigate to the project directory: `cd mini_ai`\n3. Install dependencies: `pip install -r requirements.txt` (if any)\n\n## Usage\n\n### Training the Model\n\nTo train the model with a text file, use the following command:\n```bash\npython -m mini_ai.cli train --input <path_to_text_file> --model-out <path_to_output_model> --order <int>\n```\n\n### Generating Text\n\nTo generate text using a trained model, use the following command:\n```bash\npython -m mini_ai.cli generate --model <path_to_model> --length <length_of_generated_text> [--seed <seed_character>] [--random-seed <random_seed>]\n```\n\n## Documentation for Code\n\n### MarkovChain Class\n\nThe `MarkovChain` class is responsible for training the model and generating text based on it.\n\n#### Methods:\n\n- **`__init__(order: int = 1)`**: Initializes the Markov Chain with a given order.\n- **`train(self, text: str) -> None`**: Trains the model on the provided text.\n- **`generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str`**: Generates a sequence of characters with the specified length based on the trained model. Optionally takes a seed character and a random seed for reproducibility.\n- **`to_dict() -> dict`**: Converts the model to a dictionary representation that can be serialized to JSON.\n- **`classmethod from_dict(cls, d: dict) -> 'MarkovChain'`**: Creates a `MarkovChain` instance from a dictionary representation.\n\n### CLI Module\n\nThe `cli.py` module provides a command line interface for training the model and generating text based on it.\n\n#### Main Function:\n- **`main(argv: list[str] | None = None) -> int`**: The main function that parses arguments and calls appropriate subcommands.\n\n#### Subcommands:\n\n- **train**: Trains the model from a text file and saves it to a specified output path. Accepts `--input`, `--model-out`, and `--order` arguments.\n- **generate**: Generates text using a trained model. Takes `--model`, `--length`, optional `--seed`, and `--random-seed` arguments.\n\n## Contributing\nPull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.\n\n## License\n[MIT](https://choosealicense.com/licenses/mit/)"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": ""
    },
    {
      "path": "mini_ai/markov.py",
      "content": "from typing import Dict, Optional, Union\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {next_char: 1}\n            else:\n                self.transitions[context][next_char] = self.transitions[context].get(next_char, 0) + 1\n\n    def generate(self, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        if random_seed is not None:\n            import random\n            random.seed(random_seed)\n        result = []\n        if seed is None:\n            # Choose a random starting point\n            start = random.choice(list(self.transitions.keys()))\n        else:\n            start = seed\n        for _ in range(length):\n            if start not in self.transitions:\n                break\n            next_char = max(self.transitions[start], key=self.transitions[start].get)\n            result.append(next_char)\n            start = ''.join([start[1:], next_char])\n        return ''.join(result)\n\n    def to_dict(self) -> Dict:\n        return {\"order\": self.order, \"transitions\": self.transitions}\n\n    @classmethod\n    def from_dict(cls, d: Dict) -> 'MarkovChain':\n        mc = cls(order=d['order'])\n        mc.transitions = d['transitions']\n        return mc\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nimport json\nimport os\nfrom typing import Optional\n\nfrom mini_ai.markov import MarkovChain\n\ndef main(argv: Optional[list[str]] = None) -> int:\n    parser = argparse.ArgumentParser(description='Text generation using a character-level Markov chain')\n    subparsers = parser.add_subparsers()\n\n    train_parser = subparsers.add_parser('train', help='Train the model on input text')  \n    train_parser.add_argument('--input', type=str, required=True, help='Path to the input text file')\n    train_parser.add_argument('--model-out', type=str, required=True, help='Path to save the trained model')\n    train_parser.add_argument('--order', type=int, required=True, help='Order of the Markov Chain')\n    train_parser.set_defaults(func=train)\n\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained model')  \n    generate_parser.add_argument('--model', type=str, required=True, help='Path to the trained model')\n    generate_parser.add_argument('--length', type=int, required=True, help='Length of the generated text')\n    generate_parser.add_argument('--seed', type=str, default=None, help='Seed character for generation')\n    generate_parser.add_argument('--random-seed', type=int, default=None, help='Random seed for reproducibility')\n    generate_parser.set_defaults(func=generate)\n\n    args = parser.parse_args(argv)\n    return args.func(args) if hasattr(args, 'func') else 0\n\ndef train(args):\n    with open(args.input, 'r', encoding='utf-8') as f:\n        text = f.read()\n    mc = MarkovChain(order=args.order)\n    mc.train(text)\n    with open(args.model_out, 'w', encoding='utf-8') as f:\n        json.dump(mc.to_dict(), f)\n    return 0\n\ndef generate(args):\n    with open(args.model, 'r', encoding='utf-8') as f:\n        model = MarkovChain.from_dict(json.load(f))\n    generated_text = model.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\n    print(generated_text)\n    return 0\n"
    }
  ]
}