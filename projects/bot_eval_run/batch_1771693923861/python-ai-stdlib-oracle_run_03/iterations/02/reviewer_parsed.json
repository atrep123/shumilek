{
  "mode": "full",
  "files": [
    {
      "path": "README.md"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": "from .markov import MarkovChain\n"
    },
    {
      "path": "mini_ai/markov.py",
      "content": "\nimport json\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions = {}\n\n    @property\n    def order(self) -> int:\n        return self._order\n\n    @order.setter\n    def order(self, value: int):\n        if not isinstance(value, int) or value <= 0:\n            raise ValueError('Order must be a positive integer')\n        self._order = value\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order + 1):\n            context = text[i:i+self.order]\n            next_char = text[i+self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {}\n            if next_char not in self.transitions[context]:\n                self.transitions[context][next_char] = 0\n            self.transitions[context][next_char] += 1\n\n    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\n        if not isinstance(length, int) or length <= 0:\n            raise ValueError('Length must be a positive integer')\n        if seed is not None and not isinstance(seed, str):\n            raise ValueError('Seed must be a string')\n        if random_seed is not None and not isinstance(random_seed, int):\n            raise ValueError('Random seed must be an integer')\n\n        import random\n        if seed:\n            random.seed(hash(seed))\n        elif random_seed:\n            random.seed(random_seed)\n\n        context = (random.random() * len(self.transitions.keys())).astype(int).item()\n        result = [list(self.transitions.keys())[context]]\n        for _ in range(length - 1):\n            next_char = max(self.transitions[result[-1]].keys(), key=lambda x: self.transitions[result[-1]][x])\n            result.append(next_char)\n\n        return ''.join(result)\n\n    def to_dict(self) -> dict:\n        return {\n            'order': self.order,\n            'transitions': {k: v for k, v in self.transitions.items()}\n        }\n\n    @classmethod\ndef from_dict(cls, d: dict):\n        if not isinstance(d, dict):\n            raise ValueError('Input must be a dictionary')\n        return cls(**d)\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "\nimport argparse\nfrom .markov import MarkovChain\n\nMODELS_DIR = 'models'\nDEFAULT_MODEL_PATH = os.path.join(MODELS_DIR, 'model.json')\n\ndef train(args):\n    input_path = args.input\n    model_out_path = args.model_out\n    order = args.order\n    mc = MarkovChain(order)\n    with open(input_path, 'r', encoding='utf-8') as f:\n        text = f.read()\n    mc.train(text)\n    model_path = os.path.join(MODELS_DIR, os.path.basename(model_out_path))\n    with open(model_path, 'w', encoding='utf-8') as f:\n        json.dump(mc.to_dict(), f, ensure_ascii=False, indent=4)\n\ndef generate(args):\n    model_path = args.model\n    length = args.length\n    seed = args.seed\n    random_seed = args.random_seed\n    mc = MarkovChain.from_dict(json.load(open(model_path, 'r', encoding='utf-8')))\n    result = mc.generate(length, seed, random_seed)\n    print(result)\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers(dest='command')\n    train_parser = subparsers.add_parser('train', help='Train Markov chain model from input text file and save to output path')\n    generate_parser = subparsers.add_parser('generate', help='Generate text using trained Markov chain model')\n\n    # Train command arguments\n    train_parser.add_argument('--input', required=True, type=str)\n    train_parser.add_argument('--model-out', default=DEFAULT_MODEL_PATH, type=str)\n    train_parser.add_argument('--order', type=int, default=1)\n\n    # Generate command arguments\n    generate_parser.add_argument('--model', required=True, type=str)\n    generate_parser.add_argument('--length', type=int, required=True)\n    generate_parser.add_argument('--seed', type=str, help='Seed for deterministic generation')\n    generate_parser.add_argument('--random-seed', type=int, help='Random seed for non-deterministic generation')\n\n    args = parser.parse_args()\n    if args.command == 'train':\n        train(args)\n    elif args.command == 'generate':\n        generate(args)\n"
    }
  ],
  "notes": "README.md should be created with basic instructions on how to use the package."
}