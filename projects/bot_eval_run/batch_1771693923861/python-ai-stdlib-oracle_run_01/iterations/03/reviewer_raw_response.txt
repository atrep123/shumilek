{
  "mode": "full",
  "files": [
    {"path": "mini_ai/__init__.py", "content": "\nfrom .markov import MarkovChain\n"},
    {"path": "mini_ai/markov.py", "content": "import json\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions = {}\n\n    def train(self, text: str) -> None:\n        if not isinstance(text, str):\n            raise ValueError('Text must be a string')\n        for i in range(len(text) - self.order + 1):\n            context = text[i:i+self.order]\n            next_char = text[i+self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {}\n            if next_char not in self.transitions[context]:\n                self.transitions[context][next_char] = 0\n            self.transitions[context][next_char] += 1\n\n    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\n        if not isinstance(length, int):\n            raise ValueError('Length must be an integer')\n        if length <= 0:\n            raise ValueError('Length must be greater than zero')\n\n        import random\n        if seed is not None and random_seed is not None:\n            raise ValueError('Cannot specify both seed and random_seed')\n        elif seed is not None:\n            random.seed(seed)\n        elif random_seed is not None:\n            random.seed(random_seed)\n\n        result = []\n        context = text[:self.order]\n        for _ in range(length):\n            if context not in self.transitions:\n                break\n            next_char_options = list(self.transitions[context].keys())\n            if len(next_char_options) == 1:\n                next_char = next_char_options[0]\n            else:\n                random.shuffle(next_char_options)\n                next_char = next_char_options[0]\n            result.append(next_char)\n            context = text[i:i+self.order][self.order-1:] + next_char\n        return ''.join(result)\n\n    def to_dict(self) -> dict:\n        transitions_dict = {context: {next_char: count for next_char, count in chars.items()} for context, chars in self.transitions.items()}\n        return {\n            "  }," order\": self.order,\n            \"transitions\": transitions_dict\n        }\n\n    @classmethod\ndef from_dict(cls, d: dict) -> 'MarkovChain':\n        mc = cls(d['order'])\n        for context, chars in d['transitions'].items():\n            mc.transitions[context] = {next_char: count for next_char, count in chars.items()}\n        return mc\n    }\n  ",
    {"path": "mini_ai/cli.py", "content": "\nimport argparse\nfrom .markov import MarkovChain\n\nORDER_CHOICES = [1]\n\ndef train(args):\n    text = open(args.input, 'r', encoding='utf-8').read()\n    mc = MarkovChain(order=args.order)\n    mc.train(text)\n    with open(args.model_out, 'w', encoding='utf-8') as f:\n        json.dump(mc.to_dict(), f, ensure_ascii=False)\n\ndef generate(args):\n    model_path = args.model\n    length = int(args.length)\n    seed = args.seed if args.seed else None\n    random_seed = args.random_seed if args.random_seed else None\n    mc = MarkovChain.from_dict(json.load(open(model_path, 'r', encoding='utf-8')))\n    result = mc.generate(length=length, seed=seed, random_seed=random_seed)\n    print(result)\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers(dest='command')\n    train_parser = subparsers.add_parser('train', help='Train a Markov model from input text and save to output file')\n    train_parser.add_argument('--input', type=str, required=True)\n    train_parser.add_argument('--model-out', type=str, required=True)\n    train_parser.add_argument('--order', type=int, choices=ORDER_CHOICES, default=1)\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained Markov model')\n    generate_parser.add_argument('--model', type=str, required=True)\n    generate_parser.add_argument('--length', type=int, required=True)\n    generate_parser.add_argument('--seed', type=str, default=None)\n    generate_parser.add_argument('--random-seed', type=int, default=None)\n\n    args = parser.parse_args()\n    if args.command == 'train':\n        train(args)\n    elif args.command == 'generate':\n        generate(args)\n  "}
  ],
  "notes": "Add missing files and update existing ones to ensure the project structure is correct and all required functionalities are implemented."
}