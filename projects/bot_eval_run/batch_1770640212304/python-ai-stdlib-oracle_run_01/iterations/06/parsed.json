{
  "mode": "full",
  "files": [
    {
      "path": "README.md",
      "content": "# Mini AI\n\nThis is a simple character-level Markov chain generator implemented in Python without using any external libraries.\n\n## Features\n\n- Implements a MarkovChain class with the following methods:\n  - `train(text: str) -> None`: Trains the model on the given text.\n  - `generate(length: int, seed: str | None = None, random_seed: int | None = None) -> str`: Generates text based on the trained model.\n  - `to_dict() -> dict`: Converts the model to a dictionary for serialization.\n  - `from_dict(d: dict) -> MarkovChain`: Loads the model from a dictionary.\n\n- A CLI tool with subcommands:\n  - `train --input <path> --model-out <path> --order <int>`: Trains the model and saves it to a file.\n  - `generate --model <path> --length <int> [--seed <str>] [--random-seed <int>]`: Generates text based on the trained model.\n\n## Installation\n\nTo install, simply clone this repository and run:\n```bash\npip install .\n```\n\n## Usage\n\n### Training a Model\n```bash\npython -m mini_ai.cli train --input input.txt --model-out model.json --order 1\n```\n\n### Generating Text\n```bash\npython -m mini_ai.cli generate --model model.json --length 50 --seed 'a' --random-seed 0\n```\n"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": "from .markov import MarkovChain\nfrom .cli import main\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nimport json\nfrom .markov import MarkovChain\n\ndef main(argv=None):\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers()\n\n    train_parser = subparsers.add_parser(\"train\")\n    train_parser.add_argument(\"--input\", type=str, required=True)\n    train_parser.add_argument(\"--model-out\", type=str, required=True)\n    train_parser.add_argument(\"--order\", type=int, required=True)\n    train_parser.set_defaults(func=train)\n\n    generate_parser = subparsers.add_parser(\"generate\")\n    generate_parser.add_argument(\"--model\", type=str, required=True)\n    generate_parser.add_argument(\"--length\", type=int, required=True)\n    generate_parser.add_argument(\"--seed\")\n    generate_parser.add_argument(\"--random-seed\", type=int)\n    generate_parser.set_defaults(func=generate)\n\n    args = parser.parse_args(argv)\n    return args.func(args) if hasattr(args, \"func\") else 0\n\ndef train(args):\n    with open(args.input, \"r\", encoding=\"utf-8\") as f:\n        text = f.read()\n    mc = MarkovChain(order=args.order)\n    mc.train(text)\n    with open(args.model_out, \"w\", encoding=\"utf-8\") as f:\n        json.dump(mc.to_dict(), f)\n    return 0\n\ndef generate(args):\n    with open(args.model, \"r\", encoding=\"utf-8\") as f:\n        model = MarkovChain.from_dict(json.load(f))\n    generated_text = model.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\n    print(generated_text)\n    return 0\n"
    },
    {
      "path": "mini_ai/markov.py",
      "content": "import random\nimport json\n\nclass MarkovChain:\n    def __init__(self, order: int):\n        self.order = order\n        self.chain = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            key = tuple(text[i+j] for j in range(self.order))\n            if key not in self.chain:\n                self.chain[key] = []\n            self.chain[key].append(text[i+self.order])\n\n    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\n        if random_seed is not None:\n            random.seed(random_seed)\n        elif seed is not None:\n            random.seed(seed)\n\n        start = random.choice(list(self.chain.keys()))\n        text = list(start)\n\n        while len(text) < length:\n            next_char = random.choice(self.chain[tuple(text[-self.order:])])\n            text.append(next_char)\n\n        return \"\".join(text)\n\n    def to_dict(self) -> dict:\n        return {\"order\": self.order, \"chain\": {k: v for k, v in self.chain.items() if len(v) > 0}}\n\n    @staticmethod\n    def from_dict(d: dict):\n        mc = MarkovChain(order=d[\"order\"])\n        mc.chain = {k: v for k, v in d[\"chain\"].items() if len(v) > 0}\n        return mc\n"
    },
    {
      "path": "tests/test_oracle.py",
      "content": "import unittest\nfrom mini_ai.markov import MarkovChain\nimport random\n\nclass TestMarkovChain(unittest.TestCase):\n    def test_train_and_generate(self):\n        text = \"hello world\"\n        mc = MarkovChain(order=1)\n        mc.train(text)\n        generated_text = mc.generate(length=len(text), seed=\"h\")\n        self.assertEqual(generated_text, \"ello worl\")\n\n    def test_serialization(self):\n        text = \"hello world\"\n        mc = MarkovChain(order=1)\n        mc.train(text)\n        d = mc.to_dict()\n        mc_from_dict = MarkovChain.from_dict(d)\n        generated_text = mc_from_dict.generate(length=len(text), seed=\"h\")\n        self.assertEqual(generated_text, \"ello worl\")\n"
    }
  ],
  "notes": "optional"
}