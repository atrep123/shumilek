{
  "mode": "full",
  "files": [
    {
      "path": "README.md",
      "content": "# Mini AI\n\nThis project implements a character-level Markov chain generator using Python's standard library.\n\n## Features\n\n- Implements a MarkovChain class with methods to train and generate text based on the model.\n- Provides a CLI for training the model from a text file and generating new text based on the trained model.\n\n## Installation\n\nPossibly, you can install this package using pip:\n```bash\npip install .\n```\n\n## Usage\n\n### Training the Model\nTo train the Markov chain model from a text file and save it to a JSON file, use the following command:\n```bash\npython -m mini_ai.cli train --input <path-to-text-file> --model-out <path-to-output-json> --order <int>\n```\n\n### Generating Text\nTo generate text based on the trained model, use:\n```bash\npython -m mini_ai.cli generate --model <path-to-input-json> --length <int> [--seed <str>] [--random-seed <int>]\n```\n\n## Documentation for Developers\n\n### MarkovChain Class\nThis class implements a character-level Markov chain model.\n\n#### Methods:\n- `__init__(order: int = 1)`: Initializes the MarkovChain with a given order.\n- `train(text: str) -> None`: Trains the model on the provided text.\n- `generate(length: int, seed: str | None = None, random_seed: int | None = None) -> str`: Generates text of specified length based on the trained model. Optionally starts with a given seed and uses a specific random seed for reproducibility.\n- `to_dict() -> dict`: Converts the model to a dictionary representation that can be serialized to JSON.\n- `from_dict(d: dict) -> \"MarkovChain\"`: Creates a MarkovChain instance from a dictionary representation.\n\n### CLI Module\nThis module provides a command-line interface for training and generating text based on the Markov chain model.\n\n#### Functions:\n- `main(argv: list[str] | None = None) -> int`: Main function to parse arguments and call appropriate subcommands.\n- `train(args) -> int`: Subcommand to train the model from a text file and save it to a JSON file.\n- `generate(args) -> int`: Subcommand to generate text based on the trained model.\n\n## Testing\nTo run tests, use:\n```bash\npython -m unittest discover -v -s tests -p \"test*.py\"\n```\n\n### Example\nHere's an example of how you can train and generate text using the CLI:\n```bash\ntrain --input input.txt --model-out model.json --order 1\ngenerate --model model.json --length 100 --seed \"start\" --random-seed 42\n```\n"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": ""
    },
    {
      "path": "mini_ai/markov.py",
      "content": "from typing import Dict, Tuple, List, Any\nimport random\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        if order <= 0:\n            raise ValueError(\"Order must be positive.\")\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {next_char: 1}\n            else:\n                self.transitions[context][next_char] = self.transitions[context].get(next_char, 0) + 1\n\n    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\n        if random_seed is not None:\n            random.seed(random_seed)\n        elif seed is not None:\n            random.seed(seed[:self.order])\n\n        text: List[str] = []\n        context = seed[:self.order] if seed else random.choice(list(self.transitions.keys()))\n\n        for _ in range(length):\n            if context not in self.transitions:\n                break\n\n            next_chars = list(self.transitions[context].keys())\n            weights = list(self.transitions[context].values())\n            next_char = random.choices(next_chars, weights)[0]\n\n            text.append(next_char)\n            context = context[1:] + next_char\n\n        return \"\".join(text)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\"order\": self.order, \"transitions\": self.transitions}\n\n    @staticmethod\n    def from_dict(d: Dict[str, Any]) -> \"MarkovChain\":\n        mc = MarkovChain(order=d[\"order\"])  # type: ignore\n        mc.transitions = d[\"transitions\"]  # type: ignore\n        return mc\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nimport json\nfrom .markov import MarkovChain\n\ndef main(argv=None):\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers()\n\n    train_parser = subparsers.add_parser(\"train\")\n    train_parser.add_argument(\"--input\", type=str, required=True)\n    train_parser.add_argument(\"--model-out\", type=str, required=True)\n    train_parser.add_argument(\"--order\", type=int, required=True)\n    train_parser.set_defaults(func=train)\n\n    generate_parser = subparsers.add_parser(\"generate\")\n    generate_parser.add_argument(\"--model\", type=str, required=True)\n    generate_parser.add_argument(\"--length\", type=int, required=True)\n    generate_parser.add_argument(\"--seed\")\n    generate_parser.add_argument(\"--random-seed\", type=int)\n    generate_parser.set_defaults(func=generate)\n\n    args = parser.parse_args(argv)\n    return args.func(args) if hasattr(args, \"func\") else 0\n\ndef train(args):\n    with open(args.input, \"r\", encoding=\"utf-8\") as f:\n        text = f.read()\n    mc = MarkovChain(order=args.order)\n    mc.train(text)\n    with open(args.model_out, \"w\", encoding=\"utf-8\") as f:\n        json.dump(mc.to_dict(), f)\n    return 0\n\ndef generate(args):\n    with open(args.model, \"r\", encoding=\"utf-8\") as f:\n        model = MarkovChain.from_dict(json.load(f))\n    generated_text = model.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\n    print(generated_text)\n    return 0\n"
    },
    {
      "path": "tests/test_oracle.py",
      "content": "import unittest\nfrom ..mini_ai.markov import MarkovChain\n\nclass TestMarkovChain(unittest.TestCase):\n    def test_init(self):\n        mc = MarkovChain()\n        self.assertEqual(mc.order, 1)\n        self.assertIsInstance(mc.transitions, dict)\n\n    def test_train(self):\n        mc = MarkovChain()\n        mc.train(\"abc\")\n        self.assertIn(\"a\", mc.transitions)\n        self.assertEqual(mc.transitions[\"a\"], {\"b\": 1})\n\n    def test_generate(self):\n        mc = MarkovChain()\n        mc.train(\"abc\")\n        text = mc.generate(3)\n        self.assertEqual(text, \"bc\")\n\nif __name__ == \"__main__\":\n    unittest.main()"
    }
  ],
  "notes": "optional"
}