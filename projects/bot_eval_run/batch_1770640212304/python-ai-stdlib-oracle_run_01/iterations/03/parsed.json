{
  "mode": "full",
  "files": [
    {
      "path": "README.md",
      "content": "# Mini AI\n\nThis is a simple implementation of a character-level Markov chain generator using Python.\n\n## Features\n\n- Uses standard Python library only (no numpy, pandas, sklearn, torch, tensorflow, requests).\n- Contains modules `mini_ai/markov.py` and `mini_ai/cli.py`.\n\n## Installation\n\nTo install the package, you can use pip:\n\n```bash\npip install .\n```\n\n## Usage\n\n### Training a model\n\nYou can train a Markov chain model by using the `train` subcommand. Here's an example command:\n\n```bash\npython -m mini_ai.cli train --input input.txt --model-out output.json --order 1\n```\n\n### Generating text\n\nYou can generate text using the trained model by using the `generate` subcommand. Here's an example command:\n\n```bash\npython -m mini_ai.cli generate --model output.json --length 50 --seed 'a' --random-seed 0\n```\n\n## Documentation for Developers\n\n### `mini_ai/markov.py`\n\n#### Class: MarkovChain(order: int = 1)\n\n- **Parameters:**\n  - `order`: The order of the Markov chain (default is 1).\n\n- **Methods:**\n  - `train(self, text: str) -> None`: Trains the model on the given text.\n  - `generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str`: Generates text of specified length using the trained model. Optionally, you can provide a seed and/or a random seed to control the generation process.\n  - `to_dict(self) -> dict`: Converts the model to a dictionary representation that can be serialized to JSON.\n  - @classmethod def from_dict(cls, d: dict) -> \"MarkovChain\": Creates a MarkovChain instance from a dictionary representation.\n\n#### Example Usage:\n\n```python\nmc = MarkovChain(order=1)\nmc.train('aba')\nd = mc.to_dict()\nprint(d)\n# Output: {'order': 1, 'transitions': {'a': {'b': 1}}}\n```\n\n### `mini_ai/cli.py`\n\n#### Function: main(argv: list[str] | None = None) -> int\n\n- **Parameters:**\n  - `argv`: List of command-line arguments (default is sys.argv).\n\n- **Subcommands:**\n  - `train`: Trains a Markov chain model from input text and saves it to a file.\n    - `--input <path>`: Path to the input text file.\n    - `--model-out <path>`: Path where the trained model will be saved as JSON.\n    - `--order <int>`: Order of the Markov chain.\n  - `generate`: Generates text using a trained Markov chain model.\n    - `--model <path>`: Path to the trained model JSON file.\n    - `--length <int>`: Length of the generated text.\n    - [--seed <str>]: Seed for text generation (optional).\n    - [--random-seed <int>]: Random seed for text generation (optional).\n\n#### Example Commands:\n\n```bash\ntrain --input input.txt --model-out output.json --order 1\ngenerate --model output.json --length 50 --seed 'a' --random-seed 0\n```\n"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": ""
    },
    {
      "path": "mini_ai/markov.py",
      "content": "from typing import Dict, Any, List, Union\nimport random\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}  # type hinting for mypy\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {next_char: 1}\n            else:\n                if next_char in self.transitions[context]:\n                    self.transitions[context][next_char] += 1\n                else:\n                    self.transitions[context][next_char] = 1\n\n    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\n        if random_seed is not None:\n            random.seed(random_seed)\n        elif seed is not None:\n            random.seed(seed)\n\n        if self.transitions:\n            current_context = ''.join([random.choice(list(self.transitions[k].keys())) for k in self.transitions])\n            generated_text: List[str] = list(current_context)\n\n            for _ in range(length):\n                if current_context in self.transitions:\n                    possible_chars = list(self.transitions[current_context].keys())\n                    weights = list(self.transitions[current_context].values())\n                    next_char = random.choices(possible_chars, weights=weights)[0]\n                else:\n                    next_char = ''  # or you can choose a fallback behavior\n\n                generated_text.append(next_char)\n                current_context = ''.join([current_context[1:], next_char])\n        else:\n            raise ValueError('The model has not been trained yet.')\n\n        return ''.join(generated_text)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\"order\": self.order, \"transitions\": self.transitions}\n\n    @classmethod\n    def from_dict(cls, d: Dict[str, Any]) -> 'MarkovChain':\n        model = cls(order=d['order'])\n        model.transitions = d['transitions']\n        return model\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nimport json\nfrom mini_ai.markov import MarkovChain\n\ndef main(argv=None):\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers()\n\n    # Subcommand: train\n    train_parser = subparsers.add_parser('train')\n    train_parser.add_argument('--input', required=True, help='Path to the input text file.')\n    train_parser.add_argument('--model-out', required=True, help='Path where the trained model will be saved as JSON.')\n    train_parser.add_argument('--order', type=int, required=True, help='Order of the Markov chain.')\n    train_parser.set_defaults(func=train)\n\n    # Subcommand: generate\n    generate_parser = subparsers.add_parser('generate')\n    generate_parser.add_argument('--model', required=True, help='Path to the trained model JSON file.')\n    generate_parser.add_argument('--length', type=int, required=True, help='Length of the generated text.')\n    generate_parser.add_argument('--seed', help='Seed for text generation (optional).')\n    generate_parser.add_argument('--random-seed', type=int, help='Random seed for text generation (optional).')\n    generate_parser.set_defaults(func=generate)\n\n    args = parser.parse_args(argv)\n    if 'func' in args:\n        return args.func(args)\n    else:\n        parser.print_help()\n        return 1\n\ndef train(args):\n    with open(args.input, 'r', encoding='utf-8') as file:\n        text = file.read().strip()\n    model = MarkovChain(order=args.order)\n    model.train(text)\n    with open(args.model_out, 'w', encoding='utf-8') as outfile:\n        json.dump(model.to_dict(), outfile)\n\ndef generate(args):\n    with open(args.model, 'r', encoding='utf-8') as file:\n        model = MarkovChain.from_dict(json.load(file))\n    generated_text = model.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\n    print(generated_text)\n    return 0\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "notes": "optional"
}