Vytvor realisticky Node.js projekt (bez externich zavislosti), ktery poskytuje REST API pro TODO a projde oracle testy.

POZADAVKY / KONTRAKT:
- Zadne externi npm balicky. Pouze Node.js builtin moduly.
- V kodu NEPOUZIVEJ require/import na nic mimo builtin (napr. zadne "uuid"). Pouzij `node:crypto` (`crypto.randomUUID()`).
- Kód bude v `src/` a bude CommonJS (require/module.exports).
- Soubor `src/server.js` musi exportovat funkci `createServer({ dataPath })`.
- Server musi poskytovat endpointy:
  - GET /health -> 200 JSON { ok: true }
  - GET /openapi.json -> 200 JSON OpenAPI 3.x (musí obsahovat paths pro /todos)
  - GET /todos -> 200 JSON { ok: true, todos: [...] }
  - POST /todos (body {title}) -> 201 JSON { ok: true, todo }
  - GET /todos/:id -> 200 JSON { ok:true, todo } nebo 404 JSON { ok:false, error }
  - PATCH /todos/:id (body {done:true}) -> 200 JSON { ok:true, todo }
  - DELETE /todos/:id -> 200 JSON { ok:true }
- Schema TODO objektu:
  - id: string
  - title: string
  - done: boolean
  - createdAt: ISO string
  - doneAt?: ISO string (jen kdyz done=true)
- Persistuj do souboru `dataPath` jako JSON { "todos": [...] } po kazde mutaci.
- Nevkladej testy do jinych souboru (oracle testy se pridaji zvlast). Nepouzivej duplicity stejnych cest v "files".

Poznamka: testy budeme pouzivat tyto (musis projit):
--- BEGIN ORACLE TESTS (tests/oracle.test.js) ---
const test = require('node:test');
const assert = require('node:assert/strict');
const fs = require('node:fs');
const path = require('node:path');
const os = require('node:os');

function makeTempDir() {
  return fs.mkdtempSync(path.join(os.tmpdir(), 'bot-eval-node-api-'));
}

async function startServer(dataPath) {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const mod = require('../src/server.js');
  assert.equal(typeof mod.createServer, 'function', 'src/server.js must export createServer');
  const server = mod.createServer({ dataPath });
  assert.equal(typeof server.listen, 'function');

  await new Promise(resolve => server.listen(0, '127.0.0.1', resolve));
  const addr = server.address();
  assert.ok(addr && typeof addr === 'object' && typeof addr.port === 'number');
  const baseUrl = `http://127.0.0.1:${addr.port}`;
  return { server, baseUrl };
}

async function requestJson(url, init) {
  const res = await fetch(url, init);
  const text = await res.text();
  let json = null;
  if (text.trim()) {
    try {
      json = JSON.parse(text);
    } catch {
      throw new Error(`Expected JSON response, got: ${text.slice(0, 200)}`);
    }
  }
  return { res, json, text };
}

test('GET /health + GET /openapi.json', async () => {
  const dir = makeTempDir();
  const dataPath = path.join(dir, 'db.json');
  const { server, baseUrl } = await startServer(dataPath);
  try {
    const health = await requestJson(`${baseUrl}/health`);
    assert.equal(health.res.status, 200);
    assert.equal(health.json.ok, true);

    const spec = await requestJson(`${baseUrl}/openapi.json`);
    assert.equal(spec.res.status, 200);
    assert.equal(typeof spec.json.openapi, 'string');
    assert.ok(spec.json.openapi.startsWith('3.'));
    assert.ok(spec.json.paths && typeof spec.json.paths === 'object');
    assert.ok(spec.json.paths['/todos']);
  } finally {
    await new Promise(resolve => server.close(resolve));
  }
});

test('Todo CRUD + persistence', async () => {
  const dir = makeTempDir();
  const dataPath = path.join(dir, 'db.json');
  const { server, baseUrl } = await startServer(dataPath);
  try {
    // create
    const created = await requestJson(`${baseUrl}/todos`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ title: 'Buy milk' }),
    });
    assert.equal(created.res.status, 201, created.text);
    assert.equal(created.json.ok, true);
    const id = String(created.json.todo.id);
    assert.ok(id.length > 0);
    assert.equal(created.json.todo.title, 'Buy milk');
    assert.equal(created.json.todo.done, false);
    assert.equal(typeof created.json.todo.createdAt, 'string');

    // list
    const list1 = await requestJson(`${baseUrl}/todos`);
    assert.equal(list1.res.status, 200);
    assert.equal(list1.json.ok, true);
    assert.ok(Array.isArray(list1.json.todos));
    assert.equal(list1.json.todos.length, 1);
    assert.equal(String(list1.json.todos[0].id), id);

    // get
    const get1 = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`);
    assert.equal(get1.res.status, 200);
    assert.equal(get1.json.ok, true);
    assert.equal(String(get1.json.todo.id), id);

    // done
    const done = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`, {
      method: 'PATCH',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ done: true }),
    });
    assert.equal(done.res.status, 200, done.text);
    assert.equal(done.json.ok, true);
    assert.equal(done.json.todo.done, true);
    assert.equal(typeof done.json.todo.doneAt, 'string');

    // file persistence check (after done)
    assert.ok(fs.existsSync(dataPath));
    const persisted1 = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    assert.ok(Array.isArray(persisted1.todos));
    assert.equal(persisted1.todos.length, 1);
    assert.equal(String(persisted1.todos[0].id), id);
    assert.equal(Boolean(persisted1.todos[0].done), true);

    // delete
    const del = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`, { method: 'DELETE' });
    assert.equal(del.res.status, 200, del.text);
    assert.equal(del.json.ok, true);

    const list2 = await requestJson(`${baseUrl}/todos`);
    assert.equal(list2.res.status, 200);
    assert.equal(list2.json.ok, true);
    assert.equal(list2.json.todos.length, 0);

    const persisted2 = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    assert.ok(Array.isArray(persisted2.todos));
    assert.equal(persisted2.todos.length, 0);

    // 404 cases
    const missing = await requestJson(`${baseUrl}/todos/${encodeURIComponent(id)}`);
    assert.equal(missing.res.status, 404);
    assert.equal(missing.json.ok, false);

    const badCreate = await requestJson(`${baseUrl}/todos`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({}),
    });
    assert.equal(badCreate.res.status, 400);
    assert.equal(badCreate.json.ok, false);
  } finally {
    await new Promise(resolve => server.close(resolve));
  }
});
--- END ORACLE TESTS ---

VYSTUPNI FORMAT (STRICT): vrat JEN JSON objekt tohoto tvaru:
{
  "mode": "full",
  "files": [
    {"path": "README.md", "content": "...\n"},
    {"path": "package.json", "content": "...\n"},
    {"path": "openapi.json", "content": "...\n"},
    {"path": "src/server.js", "content": "...\n"}
  ],
  "notes": "optional"
}

Pravidla:
- Zadny markdown, zadne ``` bloky, zadny text mimo JSON.
- Cesty jsou relativni, pouzij `/`, bez `..` a bez absolutnich cest.
- Nezahrnuj vlastni `tests/` (pouziji se oracle testy).
- `content` je vzdy kompletni obsah souboru (ne diff/snippet).
- `package.json` dej minimalni a nastav "type":"commonjs".

---
PLAN (planner: deepseek-r1:8b):
We are creating a Node.js project with the following structure:

- mode: "full"
- files: [
    {"path": "package.json", "content": "{\"type\": \"commonjs\"}"},
    {"path": "src/server.js", "content": "const { createServer } = require('http'); const fs = require('fs'); const path = require('path'); const crypto = require('crypto'); function createServer({ dataPath }) {
  let todos = []; try {
    const data = fs.readFileSync(dataPath);
    todos = JSON.parse(data);
  } catch (err) {
    // If the file doesn't exist, we'll create it later (empty array)
  }

  const server = createServer((req, res) => {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });
    req.on('end', () => {
      // Parse the body
      if (method === 'GET' && path === '/health') {
        sendResponse(res, 200, { message: 'OK' });
      } else if (method === 'GET' && path === '/openapi.json') {
        sendResponse(res, 200, { openapi: '3.0.1', info: { title: 'TODO API', version: '1.0.0' }, paths: { '/todos': { get: { responses: { '200': { description: 'OK', content: { 'application/json': { schema: { type: 'array', items: { type: 'object', properties: { id: { type: 'string' }, title: { type: 'string' }, done: { type: 'boolean' } } } } } } } } } } } });
      } else if (method === 'GET' && path.startsWith('/todos/')) {
        const id = path.split('/').pop();
        const todo = todos.find(todo => todo.id === id);
        if (todo) sendResponse(res, 200, todo); else sendResponse(res, 404, { message: 'Not Found' });
      } else if (method === 'GET' && path === '/todos') {
        sendResponse(res, 200, todos);
      } else if (method === 'POST' && path === '/todos') {
        const parsedBody = JSON.parse(body);
        if (!parsedBody.title) return sendResponse(res, 400, { message: 'Bad Request', errors: ['title is required'] });
        const id = crypto.randomUUID();
        todos.push({ id, title: parsedBody.title, done: false });
        fs.writeFileSync(dataPath, JSON.stringify(todos));
        sendResponse(res, 201, { message: 'Created', id });
      } else if (method === 'PATCH' && path.startsWith('/todos/')) {
        const id = path.split('/').pop();
        const todoIndex = todos.findIndex(todo => todo.id === id);
        if (todoIndex === -1) return sendResponse(res, 404, { message: 'Not Found' });
        const parsedBody = JSON.parse(body);
        if (!parsedBody.done) return sendResponse(res, 400, { message: 'Bad Request', errors: ['done is required'] });
        todos[todoIndex].done = parsedBody.done;
        fs.writeFileSync(dataPath, JSON.stringify(todos));
        sendResponse(res, 200, { message: 'Updated' });
      } else if (method === 'DELETE' && path.startsWith('/todos/')) {
        const id = path.split('/').pop();
        todos = todos.filter(todo => todo.id !== id);
        fs.writeFileSync(dataPath, JSON.stringify(todos));
        sendResponse(res, 204, { message: 'Deleted' });
      }
    });
  }); return server;
}
function sendResponse(res, status, data) {
  res.statusCode = status;
  res.setHeader('Content-Type', 'application/json');
  res.end(JSON.stringify(data));
}")},
    {"path": "openapi.json", "content": "{\"openapi\": \"3.0.1\", \"info\": {\"title\": \"TODO API\", \"version\": \"1.0.0\"}, \"paths\": {\"/todos\": {\"get\": {\"responses\": {\"200\": {\"description\": \"OK\", \"content\": {\"application/json\": {\"schema\": {\"type\": \"array\", \"items\": {\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}, \"title\": {\"type\": \"string\"}, \"done\": {\"type\": \"boolean\"}}}}}}}}}}}}}"},
    {"path": "README.md", "content": "# TODO API
This is a simple Node.js project that implements a RESTful API for managing TODO items.

## Usage
1. Install dependencies: `npm install`
2. Start the server: `node src/server.js`
3. Use any HTTP client (e.g., Postman) to send requests to the following endpoints:
- GET /health: Returns a simple health check response.
- GET /openapi.json: Returns the OpenAPI specification for the API.
- GET /todos: Returns all TODO items.
- GET /todos/:id: Returns a specific TODO item by ID.
- POST /todos: Creates a new TODO item. Requires a `title` field in the request body.
- PATCH /todos/:id: Updates a specific TODO item's `done` status. Requires a `done` field in the request body.
- DELETE /todos/:id: Deletes a specific TODO item by ID.

## Notes
- The server uses the `http` module and handles requests with callbacks.
- Error responses are sent as JSON objects with appropriate HTTP status codes.
- The API follows the OpenAPI 3.0 specification.
"}
]
