{
  "mode": "patch",
  "files": [
    {
      "path": "mini_ai/markov.py",
      "content": "from typing import Dict, List, Optional\nimport random\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        if order <= 0:\n            raise ValueError('Order must be positive.')\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {next_char: 1}\n            else:\n                self.transitions[context][next_char] = self.transitions[context].get(next_char, 0) + 1\n\n    def generate(self, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        if random_seed is not None:\n            random.seed(random_seed)\n        if seed is None:\n            context = random.choice([c for c in self.transitions for c])\n        else:\n            context = seed\n\n        result = []\n        while len(result) < length:\n            if context not in self.transitions or sum(self.transitions[context].values()) == 0:\n                break\n            choices = list(self.transitions[context].keys())\n            weights = list(self.transitions[context].values())\n            next_char = random.choices(choices, weights)[0]\n            result.append(next_char)\n            context = context[-self.order + 1:] + next_char\n        return ''.join(result)\n\n    def to_dict(self) -> Dict:\n        return {\"order\": self.order, \"transitions\": self.transitions}\n\n    @classmethod\n    def from_dict(cls, d: Dict) -> 'MarkovChain':\n        mc = cls()\n        mc.order = d['order']\n        mc.transitions = d['transitions']\n        return mc\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nimport json\nfrom mini_ai.markov import MarkovChain\n\ndef main(argv: list[str] | None = None):\n    parser = argparse.ArgumentParser(description='Text generation using a Markov chain.')\n    subparsers = parser.add_subparsers()\n\n    train_parser = subparsers.add_parser('train', help='Train the model from input text file.')\n    train_parser.add_argument('--input', type=str, required=True, help='Path to the input text file.')\n    train_parser.add_argument('--model-out', type=str, required=True, help='Path to save the trained model.')\n    train_parser.add_argument('--order', type=int, required=True, help='Order of the Markov chain.')\n    train_parser.set_defaults(func=train_command)\n\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained model.')\n    generate_parser.add_argument('--model', type=str, required=True, help='Path to the trained model JSON file.')\n    generate_parser.add_argument('--length', type=int, required=True, help='Length of the generated text.')\n    generate_parser.add_argument('--seed', type=str, default=None, help='Seed for text generation.')\n    generate_parser.add_argument('--random-seed', type=int, default=None, help='Random seed for reproducibility.')\n    generate_parser.set_defaults(func=generate_command)\n\n    args = parser.parse_args(argv)\n    if 'func' in args:\n        args.func(**vars(args))\n    else:\n        parser.print_help()\n\ndef train_command(input_path: str, output_path: str, order: int):\n    with open(input_path, 'r') as file:\n        text = file.read().strip()\n    model = MarkovChain(order)\n    model.train(text)\n    with open(output_path, 'w') as json_file:\n        json.dump(model.to_dict(), json_file)\n\ndef generate_command(model_path: str, length: int, seed: str | None = None, random_seed: int | None = None):\n    with open(model_path, 'r') as json_file:\n        model_data = json.load(json_file)\n    model = MarkovChain.from_dict(model_data)\n    generated_text = model.generate(length, seed, random_seed)\n    print(generated_text)\n"
    }
  ]
}