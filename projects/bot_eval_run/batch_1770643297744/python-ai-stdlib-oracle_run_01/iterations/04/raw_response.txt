{"mode": "patch", "files": [ {"path":"mini_ai/markov.py","content":"    def generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str:\r\n        if random_seed is not None:\r\n            random.seed(random_seed)\r\n        elif seed is not None:\r\n            random.seed(seed)\r\n\r\n        context = seed if seed else random.choice(list(self.transitions.keys()))\r\n        result = list(context)\r\n        for _ in range(length - len(context)):\r\n            if context not in self.transitions or not self.transitions[context]:\r\n                break\r\n            next_char = random.choice(list(self.transitions[context].keys()))\r\n            result.append(next_char)\r\n            context = result[-self.order:]\r\n        return ''.join(result)\r\n"}, {"path":"mini_ai/cli.py","content":"import argparse\r\nimport json\r\nimport os\r\nfrom mini_ai.markov import MarkovChain\r\n\r\ndef main(argv: list[str] | None = None) -> int:\r\n    parser = argparse.ArgumentParser(description='Mini AI CLI')\r\n    subparsers = parser.add_subparsers()\r\n\r\n    train_parser = subparsers.add_parser('train', help='Train the model from a text file.')\r\n    train_parser.add_argument('--input', type=str, required=True, help='Path to the input text file.')\r\n    train_parser.add_argument('--model-out', type=str, required=True, help='Path to save the trained model.')\r\n    train_parser.add_argument('--order', type=int, required=True, help='Order of the Markov chain.')\r\n    train_parser.set_defaults(func=train)\r\n\r\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained model.')\r\n    generate_parser.add_argument('--model', type=str, required=True, help='Path to the input model file.')\r\n    generate_parser.add_argument('--length', type=int, required=True, help='Length of the generated text.')\r\n    generate_parser.add_argument('--seed', type=str, default=None, help='Seed for text generation.')\r\n    generate_parser.add_argument('--random-seed', type=int, default=None, help='Random seed for reproducibility.')\r\n    generate_parser.set_defaults(func=generate)\r\n\r\n    args = parser.parse_args(argv) if argv is not None else parser.parse_args()\r\n    return args.func(args)\r\n\r\ndef train(args):\r\n    with open(args.input, 'r', encoding='utf-8') as file:\r\n        text = file.read().strip()\r\n    mc = MarkovChain(order=args.order)\r\n    mc.train(text)\r\n    with open(args.model_out, 'w', encoding='utf-8') as outfile:\r\n        json.dump(mc.to_dict(), outfile)\r\n    return 0\r\n\r\ndef generate(args):\r\n    with open(args.model, 'r', encoding='utf-8') as file:\r\n        model = MarkovChain.from_dict(json.load(file))\r\n    generated_text = model.generate(length=args.length, seed=args.seed, random_seed=args.random_seed)\r\n    print(generated_text)\r\n    return 0\r\n"}
]
}