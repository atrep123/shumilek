{
  "mode": "full",
  "files": [
    {
      "path": "README.md",
      "content": "# Mini AI Project\n\nThis is a simple implementation of a character-level Markov chain generator using Python.\n\n## Features\n\n- Uses only standard Python library (no external dependencies).\n- Implements a MarkovChain class with methods to train and generate text based on the model.\n- Provides a CLI for training the model from a text file and generating new text from the trained model.\n\n## Installation\n\nNo installation is required. Simply clone this repository and run the provided scripts.\n\n## Usage\n\n### Training the Model\n\nTo train the Markov chain model, use the following command:\n```bash\ntrain --input <path_to_text_file> --model-out <path_to_output_json> --order <int>\n```\n\nExample:\n```bash\ntrain --input input.txt --model-out model.json --order 1\n```\n\n### Generating Text\n\nTo generate text using the trained model, use the following command:\n```bash\ngenerate --model <path_to_model_json> --length <int> [--seed <str>] [--random-seed <int>]\n```\n\nExample:\n```bash\ngenerate --model model.json --length 100 --seed 'a' --random-seed 42\n```\n\n## Documentation for Code\n\n### MarkovChain Class\n\nThe `MarkovChain` class is responsible for training the model and generating text based on it.\n\n#### Methods:\n\n- **`__init__(order: int = 1)`**: Initializes the Markov chain with a given order.\n- **`train(self, text: str) -> None`**: Trains the model on the provided text.\n- **`generate(self, length: int, seed: str | None = None, random_seed: int | None = None) -> str`**: Generates a string of specified length based on the trained model. Optionally starts with a given seed and uses a specific random seed for reproducibility.\n- **`to_dict() -> dict`**: Converts the model to a dictionary format that can be serialized to JSON.\n- **`from_dict(cls, d: dict) -> 'MarkovChain'`**: Creates a `MarkovChain` instance from a dictionary representation.\n\n### CLI Module\n\nThe `cli.py` module provides a command-line interface for training and generating text using the Markov chain model.\n\n#### Functions:\n\n- **`main(argv: list[str] | None = None) -> int`**: Main function that parses arguments and calls appropriate subcommands.\n- **`train_command(input_path: str, output_path: str, order: int) -> None`**: Subcommand to train the model from a text file and save it as a JSON file.\n- **`generate_command(model_path: str, length: int, seed: str | None = None, random_seed: int | None = None) -> None`**: Subcommand to generate text based on the trained model.\n"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": ""
    },
    {
      "path": "mini_ai/markov.py",
      "content": "from typing import Dict, List, Optional\nimport random\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        if order <= 0:\n            raise ValueError('Order must be positive.')\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {next_char: 1}\n            else:\n                self.transitions[context][next_char] = self.transitions[context].get(next_char, 0) + 1\n\n    def generate(self, length: int, seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        if random_seed is not None:\n            random.seed(random_seed)\n        if seed is None:\n            context = random.choice([c for c in self.transitions for c])\n        else:\n            context = seed\n\n        result = []\n        while len(result) < length:\n            if context not in self.transitions or sum(self.transitions[context].values()) == 0:\n                break\n            choices = list(self.transitions[context].keys())\n            weights = list(self.transitions[context].values())\n            next_char = random.choices(choices, weights)[0]\n            result.append(next_char)\n            context = context[-self.order + 1:] + next_char\n        return ''.join(result)\n\n    def to_dict(self) -> Dict:\n        return {\"order\": self.order, \"transitions\": self.transitions}\n\n    @classmethod\n    def from_dict(cls, d: Dict) -> 'MarkovChain':\n        mc = cls()\n        mc.order = d['order']\n        mc.transitions = d['transitions']\n        return mc\n"
    },
    {
      "path": "mini_ai/cli.py",
      "content": "import argparse\nimport json\nfrom mini_ai.markov import MarkovChain\n\ndef main(argv: list[str] | None = None):\n    parser = argparse.ArgumentParser(description='Text generation using a Markov chain.')\n    subparsers = parser.add_subparsers()\n\n    train_parser = subparsers.add_parser('train', help='Train the model from input text file.')\n    train_parser.add_argument('--input', type=str, required=True, help='Path to the input text file.')\n    train_parser.add_argument('--model-out', type=str, required=True, help='Path to save the trained model.')\n    train_parser.add_argument('--order', type=int, required=True, help='Order of the Markov chain.')\n    train_parser.set_defaults(func=train_command)\n\n    generate_parser = subparsers.add_parser('generate', help='Generate text using a trained model.')\n    generate_parser.add_argument('--model', type=str, required=True, help='Path to the trained model JSON file.')\n    generate_parser.add_argument('--length', type=int, required=True, help='Length of the generated text.')\n    generate_parser.add_argument('--seed', type=str, default=None, help='Seed for text generation.')\n    generate_parser.add_argument('--random-seed', type=int, default=None, help='Random seed for reproducibility.')\n    generate_parser.set_defaults(func=generate_command)\n\n    args = parser.parse_args(argv)\n    if 'func' in args:\n        args.func(**vars(args))\n    else:\n        parser.print_help()\n\ndef train_command(input_path: str, output_path: str, order: int):\n    with open(input_path, 'r') as file:\n        text = file.read().strip()\n    model = MarkovChain(order)\n    model.train(text)\n    with open(output_path, 'w') as json_file:\n        json.dump(model.to_dict(), json_file)\n\ndef generate_command(model_path: str, length: int, seed: str | None = None, random_seed: int | None = None):\n    with open(model_path, 'r') as json_file:\n        model_data = json.load(json_file)\n    model = MarkovChain.from_dict(model_data)\n    generated_text = model.generate(length, seed, random_seed)\n    print(generated_text)\n"
    }
  ],
  "notes": "optional"
}