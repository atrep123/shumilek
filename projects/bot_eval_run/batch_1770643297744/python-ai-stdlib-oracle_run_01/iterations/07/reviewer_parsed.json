{
  "mode": "full",
  "files": [
    {
      "path": "README.md",
      "content": "...\n"
    },
    {
      "path": "mini_ai/__init__.py",
      "content": "from .markov import MarkovChain\n"
    },
    {
      "path": "mini_ai/markov.py",
      "content": "\nfrom typing import Dict, List, Optional\nimport random\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        if order <= 0:\n            raise ValueError('Order must be positive.')\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n\n    def train(self, text: str) -> None:\n        for i in range(len(text) - self.order):\n            context = text[i:i + self.order]\n            next_char = text[i + self.order]\n            if context not in self.transitions:\n                self.transitions[context] = {next_char: 1}\n            else:\n                self.transitions[context][next_char] = self.transitions[context].get(next_char, 0) + 1\n\n    def generate(self, length: int, seed: Optional[str] | None = None, random_seed: Optional[int] | None = None) -> str:\n        if random_seed is not None:\n            random.seed(random_seed)\n        if seed is None:\n            context = random.choice([c for c in self.transitions for c])\n        else:\n            context = seed\n\n        result = []\n        while len(result) < length:\n            if context not in self.transitions or sum(self.transitions[context].values()) == 0:\n                break\n            choices = list(self.transitions[context].keys())\n            weights = list(self.transitions[context].values())\n            next_char = random.choices(choices, weights)[0]\n            result.append(next_char)\n            context = context[-self.order + 1:] + next_char\n        return ''.join(result)\n\n    def to_dict(self) -> Dict:\n        return {"
    },
    "order",
    ": self.order, "
  ],
  "transitions": {}
}