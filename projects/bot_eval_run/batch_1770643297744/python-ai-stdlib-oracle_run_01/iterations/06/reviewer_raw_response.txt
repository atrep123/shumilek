{
  "mode": "full",
  "files": [
    {"path": "README.md", "content": "# Mini AI\n\nA simple Markov chain generator for generating text.\n"},
    {"path": "mini_ai/__init__.py", "content": ""},
    {"path": "mini_ai/markov.py", "content": "from typing import Dict, List, Optional, Tuple, TypeVar, Union, cast\nimport json\nimport random\nimport string\nimport collections\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n\n    @classmethod\n    def from_dict(cls, d: dict) -> 'MarkovChain':\n        return cls(**d)\n\n    def to_dict(self) -> dict:\n        return {\n            \"order\": self.order,\n            \"transitions\": self.transitions,\n        }\n\n    def train(self, text: str):\n        if not text or len(text) < self.order:\n            raise ValueError(\"Text too short for training.\")\n\n        context = [text[i : i + self.order] for i in range(len(text) - self.order)]\n        next_chars = [text[i + self.order] for i in range(len(text) - self.order)]\n        transitions = collections.defaultdict(collections.Counter)\n        for context, next_char in zip(context, next_chars):\n            transitions[context][next_char] += 1\n\n        self.transitions = dict(transitions)\n\n    def generate(self, length: int, seed: Optional[str] = None,\n                 random_seed: Optional[int] = None) -> str:\n        if not seed and not random_seed:\n            raise ValueError(\"Either seed or random_seed must be provided.\")\n\n        if seed:\n            random.seed(seed)\n\n        if random_seed:\n            random.Random(random_seed).shuffle(list(self.transitions.keys()))\n\n        result = [random.choice(candidates) for candidates in self.transitions.values()]\n        return ''.join(result[:length])"},
    {"path": "mini_ai/cli.py", "content": "import argparse\nfrom typing import Dict, List, Optional, Tuple, TypeVar, Union\nimport json\nimport os\nimport random\nimport string\nimport tempfile\nfrom mini_ai.markov import MarkovChain\n\nclass MarkovChain:\n    def __init__(self, order: int = 1):\n        self.order = order\n        self.transitions: Dict[str, Dict[str, int]] = {}\n\n    @classmethod\n    def from_dict(cls, d: dict) -> 'MarkovChain':\n        return cls(**d)\n\n    def to_dict(self) -> Dict:\n        return {\n            \"order\": self.order,\n            \"transitions\": self.transitions,\n        }\n\n    def train(self, text: str):\n        if not text or len(text) < self.order:\n            raise ValueError(\"Text too short for training.\")\n\n        context = [text[i : i + self.order] for i in range(len(text) - self.order)]\n        next_chars = [text[i + self.order] for i in range(len(text) - self.order)]\n        transitions = collections.defaultdict(collections.Counter)\n        for context, next_char in zip(context, next_chars):\n            transitions[context][next_char] += 1\n\n        self.transitions = dict(transitions)\n\n    def generate(self, length: int, seed: Optional[str] = None,\n                 random_seed: Optional[int] = None) -> str:\n        if not seed and not random_seed:\n            raise ValueError(\"Either seed or random_seed must be provided.\")\n\n        if seed:\n            random.seed(seed)\n\n        if random_seed:\n            random.Random(random_seed).shuffle(list(self.transitions.keys()))\n\n        result = [random.choice(candidates) for candidates in self.transitions.values()]\n        return ''.join(result[:length])\n\n\nclass MarkovChainCLI:\n    def __init__(self, order: int):\n        self.order = order\n        self.markov_chains: Dict[str, MarkovChain] = {}\n\n    @classmethod\n    def from_dict(cls, d: dict) -> 'MarkovChainCLI':\n        return cls(**d)\n\n    def to_dict(self) -> Dict:\n        return {\n            \"order\": self.order,\n            \"markov_chains\": self.markov_chains,\n        }\n\n    @staticmethod\ndef _load_markov_chain_from_file(path: str, order: int) -> MarkovChain:\n    with open(path, 'r', encoding='utf-8') as file:\n        d = json.load(file)\n    return MarkovChain.from_dict(d)\n\n    def train(self, model_path: str):\n        markov_chain = self._load_markov_chain_from_file(model_path, self.order)\n        self.markov_chains[model_path] = markov_chain\n\n    @staticmethod\ndef _generate_text(seed: Optional[str], random_seed: Optional[int], length: int,\n                      markov_chain: MarkovChain) -> str:\n    if seed and not random_seed:\n        random.seed(seed)\n    elif not seed and random_seed:\n        random.Random(random_seed).shuffle(list(markov_chain.transitions.keys()))\n\n    result = [random.choice(candidates) for candidates in markov_chain.transitions.values()]\n    return ''.join(result[:length])\n\n    def generate(self, model_path: str, length: int,\n                 seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        if not model_path or model_path not in self.markov_chains:\n            raise ValueError(f\"Model path {model_path} not found.\")\n\n        markov_chain = self.markov_chains[model_path]\n        return self._generate_text(seed, random_seed, length, markov_chain)\n\n    def generate_from_file(self, input_path: str, model_path: str,\n                            seed: Optional[str] = None, random_seed: Optional[int] = None) -> str:\n        with tempfile.NamedTemporaryFile('w', encoding='utf-8') as temp_input_file:\n            with open(input_path, 'r', encoding='utf-8') as input_file:\n                for line in input_file:\n                    temp_input_file.write(line)\n\n            self.train(temp_input_file.name)\n\n        return self.generate(model_path, length=12, seed=seed, random_seed=random_seed)"}
  ],
  "notes": "Fix the test failures and add missing files."
}